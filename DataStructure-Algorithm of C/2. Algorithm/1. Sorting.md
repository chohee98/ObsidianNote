# 정렬(Sorting)
- 정해진 기준에 따라 데이터를 순서대로, 그리고 체계적으로 정리하는 알고리즘
- 데이터를 가지런히 나열하는 것 자체가 목적이 아니라 데이터를 빠르고 쉽게 찾을 수 있도록 하는 것이 목적 (**탐색**)
- 고전 정렬 알고리즘; 버블 정렬, 삽입 정렬, 퀵 정렬


## 버블 정렬(Bubble Sort)
- 물 속 깊은 곳에서 수면을 향해 올라오는 거품의 모습처럼 데이터를 정렬(별칭: Sinking 정렬) -> **"자료구조를 순회하면서 이웃한 요소들끼리 데이터를 교환하며 정렬"**
- 맨 오른쪽으로 큰 수를 순서대로 뽀글거리며 올리는 방식
- 버블 정렬 비교 횟수 = (n-1)+(n-2)+(n-3)+...+(n-(n-2))+(n-(n-1)) = <mark style="background: #0E4F9FA6;">n(n-1) / 2</mark>
- 데이터가 많아지면 연산 횟수가 많아져 실제 상용 프로그램에서 사용하기에 문제 but 데이터가 적을 때는 구현이 간단하고 버그를 만들 가능성이 적다는 장점
- ![[1-1. Bubble Sort.png|450]]


#코드 
### BubbleSort.c
```c
#include <stdio.h>

void BubbleSort(int DataSet[], int Length)
{
	int i = 0;
	int j = 0;
	int temp = 0;

	for (i = 0; i < Length - 1; i++)
	{
		for (j = 0; j < Length - (i + 1); j++) // 마지막을 하나씩 제외해가며 버블정렬 반복
		{
			if (DataSet[j] > DataSet[j + 1])
			{
				temp = DataSet[j + 1];
				DataSet[j + 1] = DataSet[j];
				DataSet[j] = temp;
			}
		}
	}
}

int main(void)
{
	int DataSet[] = { 6, 4, 2, 3, 1, 5 };
	int Length = sizeof DataSet / sizeof DataSet[0];
	int i = 0;

	BubbleSort(DataSet, Length);

	for (i = 0; i < Length; i++)
	{
		printf("%d ", DataSet[i]); // 1 2 3 4 5 6
	}

	printf("\n");

	return 0;
}
```

***


## 삽입 정렬(InsertionSort)
- 책을 정리하듯이 자료구조를 **순차적으로 순회하면서 순서에 어긋나는 요소를 찾고, 그 요소를 올바른 위치에 다시 삽입해나가는 정렬** 알고리즘
- 삽입 정렬 비교 횟수 = 1+2+...+(n-2)+(n-1) = <mark style="background: #0E4F9FA6;">n(n-1) / 2</mark>
- 비교 횟수는 버블 정렬과 동일하지만 <mark style="background: #0E4F9FA6;">삽입 정렬은 자료구조가 정렬되어 있다면 한 번도 비교를 거치지 않기 때문에 평균 비교 횟수에서 차이</mark>
- `memmove 함수의 첫 번째 매개 변수는 원본 데이터가 옮겨갈 새로운 메모리의 주소, 두 번째 매개변수는 원본 데이터가 있는 주소, 세 번쨰는 이동시킬 데이터의 양(byte)으로 배열처럼 연속된 데이터를 단번에 이동시킬 때 유용, 비슷한 기능으로는 문자열을 '복사'하는 memcpy() 그러나 얘는 복사 memmove은 '이동'의 차이`
- ![[1-2. InsertionSort.png]]


#코드 
### InsertionSort.c
```c
#include <stdio.h> 
#include <string.h> 

void InsertionSort(int DataSet[], int Length)
{
    int i = 0;
    int j = 0;
    int value = 0;

    for (i = 1; i < Length; i++)
    {
        if (DataSet[i - 1] <= DataSet[i])
            continue; // 건너뛰는 역할

        value = DataSet[i];

        for (j = 0; j < i; j++)
        {
            if (DataSet[j] > value)
            {
                // 해당 위치부터 끝까지의 요소들을 한 칸씩 오른쪽으로 이동
                memmove(&DataSet[j + 1], &DataSet[j], sizeof(DataSet[0]) * (i - j));
                DataSet[j] = value;
                break;
            }
        }
    }
}

int main(void)
{
    int DataSet[] = { 6, 4, 2, 3, 1, 5 };
    int Length = sizeof DataSet / sizeof DataSet[0];
    int i = 0;

    InsertionSort(DataSet, Length);

    for (i = 0; i < Length; i++)
    {
        printf("%d ", DataSet[i]);
    }

    printf("\n");

    return 0;
}
```

***


## 퀵 정렬(Quick)
- 전쟁 전략 중 하나인 '분할 정복(Divide and Conquer)'에 바탕을 둔 알고리즘 -> 분할 정복 전략은 적군 전체를 공략하는 대신, 적군 전체를 잘게 나누어 공략하는 전법
- 퀵 정렬 동작 과정은 **기준 요소 선정 및 분할의 반복**
- 
