# ê·¸ë˜í”„
- _ì •ì _ ì˜ ì§‘í•©ì„ V, _ê°„ì„ _ ì˜ ì§‘í•©ì„ E, ê·¸ë˜í”„ë¥¼ G = (V, E) ì´ë‹¤ -> (ì •ì ì˜ ëª¨ìŒê³¼ ì´ ì •ì ì„ ì‡ëŠ” ê°„ì„ ì˜ ëª¨ìŒì´ ê²°í•©í•˜ì—¬ ê´€ê³„ê°€ í˜•ì„±ëœ ê²ƒ)
- ê°„ì„ ìœ¼ë¡œ ì—°ê²°ëœ ë‘ ì •ì ì„ ê°€ë¦¬ì¼œ ì„œë¡œ _'ì¸ì ‘'_ ë˜ëŠ” _'ì´ì›ƒ ê´€ê³„'_ ì— ìˆë‹¤ê³  ë§í•¨
- _ê²½ë¡œ_ ì˜ ê¸¸ì´ëŠ” ì •ì ê³¼ ì •ì  ì‚¬ì´ì— ìˆëŠ” ê°„ì„ ì´ ìˆ˜
- ì •ì  í•˜ë‚˜ë¥¼ ë‘ ë²ˆ ì´ìƒ ê±°ì¹˜ë„ë¡ ë˜ì–´ìˆëŠ” ê²½ë¡œë¥¼ _'ì‚¬ì´í´'_ ì´ë¼ê³  í•¨

***


## ê·¸ë˜í”„ í‘œí˜„ ë°©ë²•
- ì •ì ì˜ ì§‘í•©ì€ ë°°ì—´, ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ í‘œí˜„í•  ìˆ˜ ìˆì§€ë§Œ ë¬¸ì œëŠ” ê°„ì„ ì˜ ì§‘í•©ì„ í‘œí˜„í•˜ëŠ” ë°©ë²• -> ê°„ì„  ì¦‰, ì •ì ê³¼ ì •ì ì˜ ì¸ì ‘ ê´€ê³„ë¥¼ ì–´ë–»ê²Œ ë‚˜íƒ€ë‚´ëŠ”ê°€?
- **ì •ì  ì‚¬ì´ì˜ ì¸ì ‘ ê´€ê³„ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ë°©ë²•**: ì¸ì ‘ í–‰ë ¬(Adjacency Matrix), ì¸ì ‘ ë¦¬ìŠ¤íŠ¸(Adjacency List)

### ì¸ì ‘ í–‰ë ¬(Adjacency Matrix)
- ì •ì ë¼ë¦¬ì˜ ì¸ì ‘ ê´€ê³„ë¥¼ ë‚˜íƒ€ë‚´ëŠ” í–‰ë ¬
- NxN í¬ê¸°ì˜ í–‰ë ¬ì„ ë§Œë“¤ì–´ í•œ ì •ì ê³¼ ë˜ ë‹¤ë¥¸ ì •ì ì´ ì¸ì ‘í•´ ìˆëŠ” ê²½ìš°(ì¦‰, ì •ì  ì‚¬ì´ì— ê°„ì„ ì˜ ì¡´ì¬í•˜ëŠ” ê²½ìš°) í–‰ë ¬ì˜ ê° ì›ì†Œë¥¼ 1ë¡œ í‘œì‹œ
- ë¬´ë°©í–¥ì„± ê·¸ë˜í”„ì˜ ì¸ì ‘ í–‰ë ¬ì€ <mark style="background: #0E4F9FA6;">ì£¼ ëŒ€ê°ì„  ê¸°ì¤€ìœ¼ë¡œ ëŒ€ì¹­</mark>ì„ ì´ë£¬ë‹¤ëŠ” íŠ¹ì§•
- <mark style="background: #824CB496;">ì •ì  ê°„ì˜ ì¸ì ‘ ì—¬ë¶€ë¥¼ ë¹ ë¥´ê²Œ ì•Œ ìˆ˜ ìˆì§€ë§Œ, í–‰ë ¬ í˜•íƒœë¡œ ì €ì¥í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•˜ëŠ” ë©”ëª¨ë¦¬ ì–‘ì´ 'ì •ì ì˜ í¬ê¸°xN^2' ë§Œí¼ ì»¤ì§„ë‹¤ëŠ” ë‹¨ì </mark>
- ![[5-1. ì¸ì ‘í–‰ë ¬.png|250]]


### ì¸ì ‘ ë¦¬ìŠ¤íŠ¸(Adjacency List)
- ê·¸ë˜í”„ ë‚´ ê° ì •ì ì˜ ì¸ì ‘ ê´€ê³„ë¥¼ í‘œí˜„í•˜ëŠ” ë¦¬ìŠ¤íŠ¸
- <mark style="background: #824CB496;">ì •ì  ê°„ì˜ ì¸ì ‘ ì—¬ë¶€ë¥¼ ì•Œì•„ë‚´ê¸° ìœ„í•´ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¥¼ íƒ€ê³  ìˆœì°¨ íƒìƒ‰ì„ í•´ì•¼ í•œë‹¤ëŠ” ë‹¨ì ì´ ìˆì§€ë§Œ, ì •ì ê³¼ ê°„ì„ ì˜ ì‚½ì…ì´ ë¹ ë¥´ê³  ì¸ì ‘ ê´€ê³„ë¥¼ í‘œì‹œí•˜ëŠ” ë¦¬ìŠ¤íŠ¸ì— ì‚¬ìš©ë˜ëŠ” ë©”ëª¨ë¦¬ ì–‘ì´ ì ë‹¤ëŠ” ì¥ì </mark> (ì–´ëŠ ìë£Œêµ¬ì¡°ë¥¼ ì„ íƒí•  ê²ƒì¸ê°€ëŠ” í”„ë¡œê·¸ë¨ ëª©ì ì— ë”°ë¼ ê²°ì •)
- ![[5-2. ì¸ì ‘ë¦¬ìŠ¤íŠ¸.png|500]]

#ì½”ë“œ ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ì˜ êµ¬í˜„
#### Graph.h
```c
#ifndef GRAPH_H
#define GRAPH_H

#include <stdio.h>
#include <stdlib.h>

enum VisitMode { Visited, NotVisited };

typedef int VElementType;

typedef struct tagVertex
{
    VElementType       Data;
    int               Visited;
    int               Index;    // ì •ì ì˜ ì¸ë±ìŠ¤(ìˆœì„œ)

    struct tagVertex* Next;     // ê·¸ë˜í”„ êµ¬ì¡°ìƒ 'ë‹¤ìŒìœ¼ë¡œ ë°©ë¬¸í•  ì •ì ' (ì´ì›ƒ ì •ì  ì •ë³´x)
    struct tagEdge* AdjacencyList;  // ì •ì ê³¼ ì—°ê²°ëœ 'ì´ì›ƒ ì •ì 'ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°
} Vertex;

// ê°„ì„ ì„ ë‚˜íƒ€ë‚´ëŠ” êµ¬ì¡°ì²´
typedef struct tagEdge
{
    int    36267;      // ê°„ì„ ì˜ ê°€ì¤‘ì¹˜
    struct tagEdge* Next;
    Vertex* From;       // ê°„ì„ ì˜ ì‹œì‘ ì •ì 
    Vertex* Target;     // ê°„ì„ ì˜ ë ì •ì 
} Edge;

typedef struct tagGraph
{
    Vertex* Vertices;       // ì •ì  ëª©ë¡ì— ëŒ€í•œ í¬ì¸í„°
    int     VertexCount;    // ì •ì  ìˆ˜
} Graph;

Graph* CreateGraph();
void   DestroyGraph(Graph* G);

Vertex* CreateVertex(VElementType Data);
void    DestroyVertex(Vertex* V);

Edge* CreateEdge(Vertex* From, Vertex* Target, int Weight);
void    DestroyEdge(Edge* E);

void   AddVertex(Graph* G, Vertex* V);
void   AddEdge(Vertex* V, Edge* E);
void   PrintGraph(Graph* G);

#endif
```

#### Graph.c
```c
#include "Graph.h"

Graph* CreateGraph()   // ê·¸ë˜í”„ ìƒì„±
{
    Graph* graph = (Graph*)malloc(sizeof(Graph));
    graph->Vertices = NULL;
    graph->VertexCount = 0;

    return graph;
}

void DestroyGraph(Graph* G)
{
	// ì •ì ì´ ì—†ì„ ë–„ê¹Œì§€ ë°˜ë³µ
    while (G->Vertices != NULL)
    {
        Vertex* Vertices = G->Vertices->Next;
        DestroyVertex(G->Vertices);
        G->Vertices = Vertices;
    }

    free(G);
}

Vertex* CreateVertex(VElementType Data) // ì •ì  ìƒì„±
{
    Vertex* V = (Vertex*)malloc(sizeof(Vertex));

    V->Data = Data;
    V->Next = NULL;
    V->AdjacencyList = NULL;
    V->Visited = NotVisited;
    V->Index = -1;

    return V;
}

void DestroyVertex(Vertex* V)
{
    // ì¸ì ‘í•œ ì •ì ì´ ì—†ì„ ë•Œê¹Œì§€ ë°˜ë³µ
    while (V->AdjacencyList != NULL)
    {
        Edge* Edge = V->AdjacencyList->Next;

        DestroyEdge(V->AdjacencyList);

        V->AdjacencyList = Edge;
    }

    free(V);
}

Edge* CreateEdge(Vertex* From, Vertex* Target, int Weight)  //ê°„ì„ 
{
    Edge* E = (Edge*)malloc(sizeof(Edge));
    E->From = From;
    E->Target = Target;
    E->Next = NULL;
    E->Weight = Weight;  // ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ (ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ë‚˜ ìµœë‹¨ê²½ë¡œ íƒìƒ‰ì—ì„œ ì •ì  ì‚¬ì´ ê±°ë¦¬)

    return E;
}

void    DestroyEdge(Edge* E)
{
    free(E);
}

void AddVertex(Graph* G, Vertex* V)  // ê·¸ë˜í”„ì— ì •ì  ì¶”ê°€
{
    Vertex* VertexList = G->Vertices;  // ì •ì  ëª©ë¡ì— ëŒ€í•œ í¬ì¸í„°

    if (VertexList == NULL)
    {
        G->Vertices = V;
    }
    else
    {
        while (VertexList->Next != NULL)  // VertexList->Next ì´ì›ƒ ìƒê´€ ì—†ì´ ì •ì  ìˆœì„œ
            VertexList = VertexList->Next;

        // ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ ë’¤ì— ì´ì–´ ë¶™ì„
        VertexList->Next = V;
    }

    V->Index = G->VertexCount++;
}

void AddEdge(Vertex* V, Edge* E) // ì •ì ê³¼ ì •ì ì„ ê°„ì„ ìœ¼ë¡œ ì‡ê¸° (ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸)
{
    if (V->AdjacencyList == NULL)  // ì´ì›ƒê°„ì˜ ì •ì ì´ ì•„ì§ ì—†ìœ¼ë©´
    {
        V->AdjacencyList = E;
    }
    else
    {
        Edge* AdjacencyList = V->AdjacencyList;

        while (AdjacencyList->Next != NULL)
            AdjacencyList = AdjacencyList->Next;

        AdjacencyList->Next = E;
    }
}

void PrintGraph(Graph* G)
{
    Vertex* V = NULL;
    Edge* E = NULL;

    if ((V = G->Vertices) == NULL)
        return;

    while (V != NULL)
    {
        printf("%c : ", V->Data);

        if ((E = V->AdjacencyList) == NULL) {
            V = V->Next;
            printf("\n");
            continue;
        }

        while (E != NULL)
        {
            printf("%c[%d] ", E->Target->Data, E->Weight);
            E = E->Next;
        }

        printf("\n");

        V = V->Next;
    }

    printf("\n");
}
```

#### Test_Graph.c
```c
#include "Graph.h"

int main(void)
{
    //  ê·¸ë˜í”„ ìƒì„±     
    Graph* G = CreateGraph();

    //  ì •ì  ìƒì„± 
    Vertex* V1 = CreateVertex('1');
    Vertex* V2 = CreateVertex('2');
    Vertex* V3 = CreateVertex('3');
    Vertex* V4 = CreateVertex('4');
    Vertex* V5 = CreateVertex('5');

    //  ê·¸ë˜í”„ì— ì •ì ì„ ì¶”ê°€ 
    AddVertex(G, V1);
    AddVertex(G, V2);
    AddVertex(G, V3);
    AddVertex(G, V4);
    AddVertex(G, V5);

    //  ì •ì ê³¼ ì •ì ì„ ê°„ì„ ìœ¼ë¡œ ì‡ê¸° 
    AddEdge(V1, CreateEdge(V1, V2, 0));
    AddEdge(V1, CreateEdge(V1, V3, 0));
    AddEdge(V1, CreateEdge(V1, V4, 0));
    AddEdge(V1, CreateEdge(V1, V5, 0));

    AddEdge(V2, CreateEdge(V2, V1, 0));
    AddEdge(V2, CreateEdge(V2, V3, 0));
    AddEdge(V2, CreateEdge(V2, V5, 0));

    AddEdge(V3, CreateEdge(V3, V1, 0));
    AddEdge(V3, CreateEdge(V3, V2, 0));

    AddEdge(V4, CreateEdge(V4, V1, 0));
    AddEdge(V4, CreateEdge(V4, V5, 0));

    AddEdge(V5, CreateEdge(V5, V1, 0));
    AddEdge(V5, CreateEdge(V5, V2, 0));
    AddEdge(V5, CreateEdge(V5, V4, 0));

    PrintGraph(G);

    //  ê·¸ë˜í”„ ì†Œë©¸ 
    DestroyGraph(G);

    return 0;
}
```
![[5-3. GraphResult.png]]

***



## ê·¸ë˜í”„ ìˆœíšŒ ğŸ˜µâ€ğŸ’«
### ê¹Šì´ ìš°ì„  íƒìƒ‰(Depth First Search)
- ê·¸ë˜í”„ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì˜ ê¸°ë°˜
- _'ë” ë‚˜ì•„ê°ˆ ê¸¸ì´ ë³´ì´ì§€ ì•Šì„ ë•Œê¹Œì§€ ê¹Šì´ ë“¤ì–´ê°„ë‹¤'_
- ê¸¸ì´ ë‚˜ì˜¤ì§€ ì•Šì„ ë•Œê¹Œì§€ ê·¸ë˜í”„ì˜ ì •ì ì„ íƒ€ê³  ê¹Šì´ ë“¤ì–´ê°€ë‹¤ê°€ ë” ì´ìƒ ë°©ë¬¸í•´ì™”ë˜ ì •ì  ë§ê³ ëŠ” ë‹¤ë¥¸ ì´ì›ƒì„ ê°–ê³  ìˆì§€ ì•Šì€ ì •ì ì„ ë§Œë‚˜ë©´ ë’¤ë¡œ ëŒì•„ë‚˜ì™€ ë‹¤ë¥¸ ê²½ë¡œë¡œ ë»—ì–´ ìˆëŠ” ì •ì ì„ íƒ€ê³  ë°©ë¬¸ì„ ì¬ê°œ
- ![[5-4. ê¹Šì´ìš°ì„ íƒìƒ‰1.png|390]] ![[5-5. ê¹Šì´ìš°ì„ íƒìƒ‰2.png|280]]
```c
// GraphTraversal.c
void DFS(Vertex* V)
{
	Edge* E = NULL;
	printf("%d", V->Data);

	// ë°©ë¬¸í•œ ì •ì ì— 'ë°©ë¬¸í–ˆìŒ'ì´ë¼ê³  í‘œì‹œ
	V->Visited = Visited;

	// ì •ì ê³¼ ì¸ì ‘í•œ ì •ì  -> DFS()ë¥¼ ì¬ê·€ í˜¸ì¶œ
	E = V->AdjacencyList;
	while ( E != NULL )
	{
		if ( E->Target != NULL && E->Target->Visited == NotVisited )
			DFS( E->Target );   // ì¸ì ‘ ì •ì ì„ ì‹œì‘ìœ¼ë¡œ ë‹¤ì‹œ ê¹Šì´ ìš°ì„  íƒìƒ‰ ì‹œì‘

		E = E->Next;
	}
}
```


### ë„ˆë¹„ ìš°ì„  íƒìƒ‰(Breadth First Search)
- ê·¸ë˜í”„ì—ì„œ ìµœë‹¨ ê²½ë¡œë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜ì˜ ê¸°ë°˜
- _'ê¼¼ê¼¼í•˜ê²Œ ì¢Œìš°ë¥¼ ì‚´í”¼ë©° ë‹¤ë‹ˆì'_
- ì‹œì‘ ì •ì ì„ ì§€ë‚œ í›„ ê¹Šì´ê°€ 1ì¸ ëª¨ë“  ì •ì ì„ ë°©ë¬¸í•˜ê³  ê·¸ ë‹¤ìŒì—ëŠ” ê¹Šì´ê°€ 2ì¸ ëª¨ë“  ì •ì  ë°©ë¬¸
- ê¹Šì´ ìš°ì„  íƒìƒ‰ì€ ë³„ë„ì˜ ìë£Œêµ¬ì¡° ì—†ì´ ì¬ê·€ í˜¸ì¶œì„ ì´ìš©í•˜ì—¬ êµ¬í˜„í•  ìˆ˜ ìˆì—ˆì§€ë§Œ, ë„ˆë¹„ ìš°ì„  íƒìƒ‰ì€ íƒìƒ‰ì„ ë„ì™€ì¤„ íê°€ ë”°ë¡œ í•„ìš” (ì²˜ìŒì— ì‹œì‘ ì •ì ì„ íì— ë„£ê³  ì´í›„, íì˜ ì „ë‹¨ì— ìˆëŠ” ì •ì ì„ ì œê±°í•˜ê³  ì´ ì •ì ì˜ ì¸ì ‘ ì •ì ì„ íì— ë„£ëŠ”ë‹¤. ì´ ì‘ì—…ì„ íê°€ ë¹Œ ë•Œê¹Œì§€ ë°˜ë³µ)
- ![[5-6. ë„ˆë¹„ìš°ì„ íƒìƒ‰1.png|315]]   ![[5-7. ë„ˆë¹„ìš°ì„ íƒìƒ‰2.png|300]]
```c
// GraphTraversal.c
void BFS( Vertex* V, LinkedQueue* Queue )
{
    Edge* E = NULL;

    printf("%d ", V->Data);
    V->Visited = Visited;
    
    // ì‹œì‘ ì •ì ì„ íì— ì‚½ì…
    LQ_Enqueue( Queue, LQ_CreateNode( V ) );

    while ( !LQ_IsEmpty( Queue ) )   // íê°€ ë¹„ì–´ìˆëŠ”ì§€ ê²€ì‚¬
    {
        Node* Popped = LQ_Dequeue( Queue );  // íë¥¼ ì „ë‹¨ì—ì„œ ì œê±°
        V = Popped->Data;
        E = V->AdjacencyList;

        while ( E != NULL )
        {
            V = E->Target;   // íì—ì„œ êº¼ë‚¸ ì •ì ì˜ ì¸ì ‘ ì •ì ì„ ì¡°ì‚¬

            if ( V != NULL && V->Visited == NotVisited )  // ë¯¸ë°©ë¬¸ ì •ì ë§Œ ë°©ë¬¸
            {
                printf("%d ", V->Data);
                V->Visited = Visited;
                LQ_Enqueue( Queue, LQ_CreateNode( V ) ); // íì— ì‚½ì…
            }
            E = E->Next; // ì¸ì ‘í•œ ë‹¤ë¥¸ ê°„ì„  (ex. 3ìœ¼ë¡œ ë»—ì–´ìˆëŠ” ì„ )
        }
    }
}
```

#ì½”ë“œ Graph ì½”ë“œì—ì„œ ì¶”ê°€ëœ ë¶€ë¶„
> (Graph.h, Graph.c, LinkedQueue.h, LinkedQueue.c, GraphTraversal.h, GraphTraversal.c, Test_GraphTraversal.c)
#### LinkedQueue.h
```c
#ifndef LINKED_QUEUE_H
#define LINKED_QUEUE_H

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "Graph.h"

typedef struct tagNode
{
    Vertex*         Data;
    struct tagNode* NextNode;
} Node;

typedef struct tagLinkedQueue
{
    Node* Front;
    Node* Rear;
    int   Count;
} LinkedQueue;

void  LQ_CreateQueue( LinkedQueue** Queue );
void  LQ_DestroyQueue( LinkedQueue* Queue );

Node* LQ_CreateNode(Vertex* V);
void  LQ_DestroyNode(Node* _Node);

void  LQ_Enqueue( LinkedQueue* Queue, Node* NewNode );
Node* LQ_Dequeue( LinkedQueue* Queue );

int   LQ_IsEmpty( LinkedQueue* Queue );

#endif

```

#### LinkedQueue.c
```c
#include "LinkedQueue.h"

void  LQ_CreateQueue( LinkedQueue** Queue )
{
    //  íë¥¼ ììœ  ì €ì¥ì†Œì— ìƒì„± 
    (*Queue )        = ( LinkedQueue*)malloc(sizeof( LinkedQueue ) );
    (*Queue )->Front = NULL;
    (*Queue )->Rear  = NULL;
    (*Queue )->Count = 0;
}

void LQ_DestroyQueue( LinkedQueue* Queue )
{
    while ( !LQ_IsEmpty( Queue ) )
    {
        Node* Popped = LQ_Dequeue( Queue );
        LQ_DestroyNode(Popped);    
    }

    //  íë¥¼ ììœ  ì €ì¥ì†Œì—ì„œ í•´ì œ 
    free( Queue );
}

Node* LQ_CreateNode(Vertex* V)
{
    Node* NewNode = (Node*)malloc(sizeof(Node));
    NewNode->Data = V;

    NewNode->NextNode = NULL; //  ë‹¤ìŒ ë…¸ë“œì— ëŒ€í•œ í¬ì¸í„°ëŠ” NULLë¡œ ì´ˆê¸°í™”í•œë‹¤. 

    return NewNode;//  ë…¸ë“œì˜ ì£¼ì†Œë¥¼ ë°˜í™˜í•œë‹¤. 
}

void  LQ_DestroyNode(Node* _Node)
{
    free(_Node->Data);
    free(_Node);
}

void LQ_Enqueue(LinkedQueue* Queue, Node* NewNode)
{
    if ( Queue->Front == NULL ) 
    {        
        Queue->Front = NewNode;
        Queue->Rear  = NewNode;
        Queue->Count++;
    } 
    else
    {
        Queue->Rear->NextNode = NewNode;
        Queue->Rear = NewNode;
        Queue->Count++;
    }
}

Node* LQ_Dequeue(LinkedQueue* Queue)
{
    Node* Front = Queue->Front;

    if ( Queue->Front->NextNode == NULL )
    {
        Queue->Front = NULL;
        Queue->Rear  = NULL;
    }
    else
    {
        Queue->Front = Queue->Front->NextNode;
    }

    Queue->Count--;

    return Front;
}

int LQ_IsEmpty(LinkedQueue* Queue)
{
    return (Queue->Front == NULL);
}

```


#### GraphTraversal.h
```c
#ifndef GRAPH_TRAVERSAL_H
#define GRAPH_TRAVERSAL_H

#include "Graph.h"
#include "LinkedQueue.h"

void DFS( Vertex* V );
void BFS( Vertex* V, LinkedQueue* Queue );

#endif
```
#### Test_GraphTraversal.c
```c
// mainë¬¸ ë‚´ë¶€ ì¶”ê°€ëœ ë¶€ë¶„
printf( "Enter Traversal Mode (0:DFS, 1:BFS) : " );
    scanf(  "%d", &Mode );

    if ( Mode == 0  ) 
    {
        //  ê¹Šì´ ìš°ì„  íƒìƒ‰ 
        DFS( graph->Vertices );
    }
    else
    {
        LinkedQueue* Queue = NULL;
        LQ_CreateQueue(&Queue);
    
        //  ë„ˆë¹„ ìš°ì„  íƒìƒ‰ 
        BFS(V1, Queue);
        
        LQ_DestroyQueue( Queue );
    }
```


***


## ìœ„ìƒ ì •ë ¬(Topological Scan)
- ìœ„ìƒ: ì–´ë–¤ ì •ì ì´ ë‹¤ë¥¸ ì •ì ê³¼ì˜ ê´€ê³„ ì†ì—ì„œ ê°€ì§€ëŠ” **ìœ„ì¹˜**(ê°„ì„  ë°©í–¥) ì†ì„±
- ê°„ì„ ì˜ ì•/ë’¤ ê´€ê³„ë¥¼ ì°¨ê·¼ì°¨ê·¼ ì •ë ¬í•˜ëŠ” ì‘ì—…
- ìœ„ìƒì„ ì •ë ¬í•˜ë ¤ë©´ ì²«ì§¸ë¡œ ê·¸ë˜í”„ì— ë°©í–¥ì„±ì´ ìˆì–´ì•¼ í•˜ê³ , ë‘˜ì§¸ë¡œ ê·¸ë˜í”„ ë‚´ì— ì‚¬ì´í´ì´ ì—†ì–´ì•¼ í•œë‹¤. ì´ëŸ° ê·¸ë˜í”„ë¥¼ **DAG(Directed Acyclic Graph)** ë¼ê³  í•¨.

### ë™ì‘ ë°©ì‹
- ê°„ì„ ì€ ë‘ ì •ì ì´ ì´ì›ƒ(íŠ¹ì • ì •ì ì— ì§ì ‘ ì—°ê²°ëœ ë‹¤ë¥¸ ì •ì ) ë˜ëŠ” ì¸ì ‘ ê´€ê³„(ì •ì  ì‚¬ì´ ê°„ì„  ì¡´ì¬)ì— ìˆë‹¤ëŠ” ì‚¬ì‹¤ ë¿ ì•„ë‹ˆë¼ ê°„ì„ ì´ ë°©í–¥ì„±ì„ ê°€ì§„ ê²½ìš° ì–´ëŠ ì •ì ì´ ì„ ì´ê³  ì–´ëŠ ì •ì ì´ í›„ì¸ì§€ë„ ì„¤ëª…
- ë°©í–¥ì„± ê°„ì„  ë‘ ê°€ì§€: ì§„ì… ê°„ì„ (Incoming Edge), ì§„ì¶œ ê°„ì„ (Outgoing Edge)
- <mark style="background: #0E4F9FA6;">ê·¸ë˜í”„ì—ì„œ 'ì§„ì… ê°„ì„ ì´ ì—†ëŠ” ì •ì 'ì„ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€í•˜ê³  í•´ë‹¹ ì •ì  ìì‹ ê³¼ ì§„ì¶œ ê°„ì„ ì„ ì œê±° ë°˜ë³µí•˜ì—¬ ìœ„ìƒ ì •ë ¬ëœ ê·¸ë˜í”„ê°€ ì €ì¥</mark>
- B -> E -> A -> D -> G -> C -> F -> H
  ![[5-8. ìœ„ìƒì •ë ¬1.png]]
- (ì¢€ ë” ìš°ì•„í•˜ê²Œ ë¬¸ì œë¥¼ í‘¸ëŠ” ì•Œê³ ë¦¬ì¦˜) **ê¹Šì´ ìš°ì„  íƒìƒ‰ì„ ì´ìš©í•œ ìœ„ìƒ ì •ë ¬**
	- ê·¸ë˜í”„ì—ì„œ ì§„ì… ê°„ì„ ì´ ì—†ëŠ” ì •ì ì— ëŒ€í•´ ê¹Šì´ ìš°ì„  íƒìƒ‰ì„ ì‹œí–‰í•˜ê³ , <mark style="background: #824CB496;">íƒìƒ‰ ì¤‘ì— ë” ì´ìƒ ì˜®ê²¨ê°ˆ ìˆ˜ ìˆëŠ” ì¸ì ‘ ì •ì ì´ ì—†ëŠ” ì •ì ì„ ë§Œë‚˜ë©´ ì´ ì •ì ì„ ë¦¬ìŠ¤íŠ¸ì˜ ìƒˆë¡œìš´ 'í—¤ë“œ'ë¡œ ì…ë ¥</mark>
	- B -> E -> A -> D -> G -> C -> F -> H 
	  ![[5-9. ìœ„ìƒì •ë ¬2.png]]

#ì½”ë“œ 
> (Graph.h, Graph.c, LinkedList.h, LinkedList.c, TopologicalSort.h, TopologicalSort.c, Test_TopologicalSort.c)

#### LinkedList.h
```c
#ifndef LINKEDLIST_H
#define LINKEDLIST_H

#include <stdio.h>
#include <stdlib.h>
#include "Graph.h"

typedef Vertex* ElementType;

typedef struct tagNode
{
    ElementType Data;
    struct tagNode* NextNode;
} Node;

// í•¨ìˆ˜ ì›í˜• ì„ ì–¸ 
Node* SLL_CreateNode(ElementType NewData);
void  SLL_DestroyNode(Node* Node);
void  SLL_AppendNode(Node** Head, Node* NewNode);
void  SLL_InsertAfter(Node* Current, Node* NewNode);
void  SLL_InsertNewHead(Node** Head, Node* NewHead);
void  SLL_RemoveNode(Node** Head, Node* Remove);
Node* SLL_GetNodeAt(Node* Head, int Location);
int   SLL_GetNodeCount(Node* Head);

#endif

```

#### LinkedList.c
```c
#include "LinkedList.h"

//  ë…¸ë“œ ìƒì„± 
Node* SLL_CreateNode(ElementType NewData)
{
    Node* NewNode = (Node*)malloc(sizeof(Node));

    NewNode->Data = NewData;  //  ë°ì´í„°ë¥¼ ì €ì¥í•œë‹¤. 
    NewNode->NextNode = NULL; //  ë‹¤ìŒ ë…¸ë“œì— ëŒ€í•œ í¬ì¸í„°ëŠ” NULLë¡œ ì´ˆê¸°í™” í•œë‹¤. 

    return NewNode;//  ë…¸ë“œì˜ ì£¼ì†Œë¥¼ ë°˜í™˜í•œë‹¤. 
}

//  ë…¸ë“œ ì†Œë©¸ 
void SLL_DestroyNode(Node* Node)
{
    free(Node);
}

//  ë…¸ë“œ ì¶”ê°€ 
void SLL_AppendNode(Node** Head, Node* NewNode)
{
    //  í—¤ë“œ ë…¸ë“œê°€ NULLì´ë¼ë©´ ìƒˆë¡œìš´ ë…¸ë“œê°€ Head 
    if ( (*Head) == NULL ) 
    {        
        *Head = NewNode;
    } 
    else
    {
        //  í…Œì¼ì„ ì°¾ì•„ NewNodeë¥¼ ì—°ê²°í•œë‹¤. 
        Node* Tail = (*Head);
        while ( Tail->NextNode != NULL )
        {
            Tail = Tail->NextNode;
        }

        Tail->NextNode = NewNode;
    }
}

//  ë…¸ë“œ ì‚½ì… 
void SLL_InsertAfter(Node* Current, Node* NewNode)
{
    NewNode->NextNode = Current->NextNode;
    Current->NextNode = NewNode;
}

void  SLL_InsertNewHead(Node** Head, Node* NewHead)
{
    if ( Head == NULL )
    {
        (*Head) = NewHead;    
    }
    else
    {
        NewHead->NextNode = (*Head);
        (*Head) = NewHead;
    }
}

//  ë…¸ë“œ ì œê±° 
void SLL_RemoveNode(Node** Head, Node* Remove)
{
    if ( *Head == Remove )
    {
        *Head = Remove->NextNode;
    }
    else
    {
        Node* Current = *Head;
        while ( Current != NULL && Current->NextNode != Remove )
        {
            Current = Current->NextNode;
        }

        if ( Current != NULL )
            Current->NextNode = Remove->NextNode;
    }
}

//  ë…¸ë“œ íƒìƒ‰ 
Node* SLL_GetNodeAt(Node* Head, int Location)
{
    Node* Current = Head;

    while ( Current != NULL && (--Location) >= 0)
    {
        Current = Current->NextNode;
    }

    return Current;
}

//  ë…¸ë“œ ê°œìˆ˜ ì„¸ê¸° 
int SLL_GetNodeCount(Node* Head)
{
    int   Count = 0;
    Node* Current = Head;

    while ( Current != NULL )
    {
        Current = Current->NextNode;
        Count++;
    }

    return Count;
}

```


#### TopologicalSort.h
```c
#include "Graph.h"
#include "LinkedList.h"

#ifndef TOPOLOGICALSORT_H
#define TOPOLOGICALSORT_H

void TopologicalSort( Vertex* V, Node** List );
void TS_DFS( Vertex* V, Node** List );

#endif
```
#### TopologicalSort.c
```c
#include "TopologicalSort.h"

void TopologicalSort( Vertex* V, Node** List )
{
    while ( V != NULL && V->Visited == NotVisited )
    {
        TS_DFS( V, List );

        V = V->Next;
    }
}

// ê¹Šì´ ìš°ì„  íƒìƒ‰
void TS_DFS( Vertex* V, Node** List )
{
    Node* NewHead = NULL;
    Edge* E = NULL;

    V->Visited = Visited;

    E = V->AdjacencyList;

    while ( E != NULL )
    {
        if ( E->Target != NULL && E->Target->Visited == NotVisited )
            TS_DFS( E->Target, List );

        E = E->Next;
    }

    printf("%c\n", V->Data );  // H F C G D A E B

    NewHead = SLL_CreateNode( V ); 
    SLL_InsertNewHead( List, NewHead ); // H ë¶€í„° í—¤ë“œë¡œ ë§Œë“¤ì–´ í—¤ë“œ ì•ì— ë¼ì›Œë„£ê¸°
}
```
#### Test_TopologicalSort.c
```c
#include "Graph.h"
#include "TopologicalSort.h"

int main( void )
{
    Node* SortedList  = NULL;
    Node* CurrentNode = NULL;

    //  ê·¸ë˜í”„ ìƒì„±     
    Graph* graph = CreateGraph();
    
    //  ì •ì  ìƒì„± 
    
    Vertex* A = CreateVertex( 'A' );
    Vertex* B = CreateVertex( 'B' );
    Vertex* C = CreateVertex( 'C' );
    Vertex* D = CreateVertex( 'D' );
    Vertex* E = CreateVertex( 'E' );
    Vertex* F = CreateVertex( 'F' );
    Vertex* G = CreateVertex( 'G' );
    Vertex* H = CreateVertex( 'H' );
    
    //  ê·¸ë˜í”„ì— ì •ì ì„ ì¶”ê°€ 
    AddVertex( graph, A );
    AddVertex( graph, B );
    AddVertex( graph, C );
    AddVertex( graph, D );
    AddVertex( graph, E );
    AddVertex( graph, F );
    AddVertex( graph, G );
    AddVertex( graph, H );

    //  ì •ì ê³¼ ì •ì ì„ ê°„ì„ ìœ¼ë¡œ ì‡ê¸° 
    AddEdge( A, CreateEdge( A, C, 0 ) );
    AddEdge( A, CreateEdge( A, D, 0 ) );

    AddEdge( B, CreateEdge( B, C, 0 ) );
    AddEdge( B, CreateEdge( B, E, 0 ) );

    AddEdge( C, CreateEdge( C, F, 0 ) );
    
    AddEdge( D, CreateEdge( D, F, 0 ) );
    AddEdge( D, CreateEdge( D, G, 0 ) );

    AddEdge( E, CreateEdge( E, G, 0 ) );

    AddEdge( F, CreateEdge( F, H, 0 ) );
    
    AddEdge( G, CreateEdge( G, H, 0 ) );

    //  ìœ„ìƒ ì •ë ¬ 
    TopologicalSort( graph->Vertices, &SortedList );

 
    printf("Topological Sort Result : ");

    CurrentNode = SortedList;

    while ( CurrentNode != NULL )
    {
	    // Nodeì˜ Dataê°€ typedef Vertex* ElementType ì´ë¯€ë¡œ ì •ì ì˜ Dataê¹Œì§€ ì´ë™
        printf("%C ", CurrentNode->Data->Data ); // B E A D G C F H
        CurrentNode = CurrentNode->NextNode;
    }
    printf("\n");
    

    //  ê·¸ë˜í”„ ì†Œë©¸ 
    DestroyGraph( graph );

    return 0;
}

```

***


## ìµœì†Œ (ê°€ì¤‘ì¹˜) ì‹ ì¥ íŠ¸ë¦¬(Minimum Spanning Tree)
- ì‹ ì¥ íŠ¸ë¦¬ëŠ” ê·¸ë˜í”„ì´ ëª¨ë“  ì •ì ì„ ì—°ê²°í•˜ëŠ” íŠ¸ë¦¬ë¡œ, ê·¸ë˜í”„ì˜ í•˜ìœ„ ê°œë… (ê·¸ë˜í”„ì—ì„œ ì‚¬ì´í´ì„ í˜•ì„±í•˜ëŠ” ê°„ì„ ë§Œ ì œê±°í•˜ë©´ íŠ¸ë¦¬ë¡œ ë³€ì‹ )
- **ì—¬ëŸ¬ ê°„ì„  ì¤‘ ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œê°€ ë˜ëŠ” ê°„ì„ ë§Œ ë‚¨ê¸´ ì‹ ì¥ íŠ¸ë¦¬** (ex. ìƒˆë¡œìš´ í˜¸í…”ì˜ ë°°ê´€ì„ ìµœì†Œ ë¹„ìš©ìœ¼ë¡œ êµ¬ì¶•í•  ë•Œ)
- ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜ì˜ ë‘ ê°€ì§€ ê¸°ë²•: í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜(Prim's Algorithm), í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜(Kruskal's Algorithm)

### í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜
- ë¹„ì–´ ìˆëŠ” ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— ì„ì˜ì˜ ì‹œì‘ ì •ì ì„ ë„£ê³  ê·¸ë˜í”„ì—ì„œ ì´ ì •ì ê³¼ ì¸ì ‘ ì •ì  ì‚¬ì´ì— ìˆëŠ” ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ë¥¼ ì¡°ì‚¬í•˜ì—¬ <mark style="background: #0E4F9FA6;">ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ì‘ì€ ê²ƒì„ ê³¨ë¼ ì—°ê²°ëœ ì¸ì ‘ ì •ì ì„ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ ì‚½ì…</mark> (ìƒˆë¡œ ì‚½ì…ë˜ëŠ” ì •ì ì€ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì˜ ê¸°ì¡´ ë…¸ë“œì™€ ì‚¬ì´í´ì„ í˜•ì„±í•˜ë©´ ì•ˆë¨)
- (C-F ê°„ì„ ì€ B-C-Fë¥¼ í†µê³¼í•˜ëŠ” ì‚¬ì´í´ì„ í˜•ì„±í•˜ê¸° ë•Œë¬¸ì— ì œì™¸, C-Fì™€ B-F ì¤‘ C-F ê°€ì¤‘ì¹˜ê°€ ë” ì»¤ì„œ C-F ì œì™¸ ) 
  ![[5-10. í”„ë¦¼ì•Œê³ ë¦¬ì¦˜1.png|600]]
  ![[5-11. í”„ë¦¼ì•Œê³ ë¦¬ì¦˜2.png|600]]
- ì•Œê³ ë¦¬ì¦˜ êµ¬í˜„ ë¬¸ì œ
	1. ì–´ë–¤ ìë£Œêµ¬ì¡°ë¥¼ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— ì‚¬ìš©? -> 'ê·¸ë˜í”„'
	2. ì¡°ì‚¬ ëŒ€ìƒ ê°„ì„  ì¤‘ ìµœì†Œ ê°€ì¤‘ì¹˜ë¥¼ ê°€ì§„ ê²ƒì„ ê³¨ë¼ë‚´ëŠ” ê³¼ì •ì—ì„œ ë°œìƒí•˜ëŠ” ì„±ëŠ¥ ë¬¸ì œ -> ìš°ì„ ìˆœìœ„ í
```c
void Prim(Graph* G, Vertex* StartVertex, Graph* MST )
{
    int i = 0;

	// ìš°ì„ ìˆœìœ„ íì—ì„œ ì‚¬ìš©í•  ì‹œì‘ ë…¸ë“œì™€ ìš°ì„ ìˆœìœ„ í ì´ˆê¸°í™”
    PQNode         StartNode = { 0, StartVertex };
    PriorityQueue* PQ        = PQ_Create(10);

	// í˜„ì¬ ì •ì ê³¼ ê°„ì„ ì„ ë‚˜íƒ€ë‚´ëŠ” í¬ì¸í„° ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ê³  ì´ˆê¸°í™”
    Vertex*  CurrentVertex = NULL;
    Edge*    CurrentEdge   = NULL; 

	// ì •ì ì˜ ê°€ì¤‘ì¹˜, MSTì— ì†í•œ ì •ì  ë°°ì—´, í˜„ì¬ ê°€ì¥ìë¦¬ ë°°ì—´, ì„ í–‰ì •ì ë°°ì—´ì„ ë™ì  í• ë‹¹
    int*     Weights       = (int*) malloc( sizeof(int) * G->VertexCount );
    Vertex** MSTVertices   = (Vertex**) malloc( sizeof(Vertex*) * G->VertexCount );
    Vertex** Fringes       = (Vertex**) malloc( sizeof(Vertex*) * G->VertexCount );
    Vertex** Precedences   = (Vertex**) malloc( sizeof(Vertex*) * G->VertexCount );

	// ê·¸ë˜í”„ì˜ ëª¨ë“  ì •ì ì„ ë°˜ë³µí•˜ì—¬ ì²˜ë¦¬
    CurrentVertex = G->Vertices;
    while ( CurrentVertex != NULL )
    {
	    // í˜„ì¬ ì •ì ì„ ë³µì‚¬í•˜ì—¬ ìƒˆë¡œìš´ ì •ì ì„ ë§Œë“¤ê³  ì´ë¥¼ ê·¸ë˜í”„ MSTì— ì¶”ê°€
        Vertex* NewVertex = CreateVertex( CurrentVertex->Data );
        AddVertex( MST, NewVertex);

		// ê° ë°°ì—´ì˜ ì´ˆê¸°ê°’ ì„¤ì •
        Fringes[i]     = NULL;
        Precedences[i] = NULL;
        MSTVertices[i] = NewVertex;        
        Weights[i]     = MAX_WEIGHT;  // 36267
        // ë‹¤ìŒ ì •ì ìœ¼ë¡œ ì´ë™í•˜ê³  ì¸ë±ìŠ¤ ì¦ê°€   
        CurrentVertex  = CurrentVertex->Next;
        i++;
    }

	// ì‹œì‘ ë…¸ë“œë¥¼ ìš°ì„ ìˆœìœ„ íì— ì¶”ê°€
    PQ_Enqueue ( PQ, StartNode );

	// ì‹œì‘ ì •ì ì˜ ê°€ì¤‘ì¹˜ë¥¼ 0ìœ¼ë¡œ ì„¤ì •
    Weights[StartVertex->Index] = 0;

	// ìš°ì„  ìˆœìœ„ íê°€ ë¹„ì–´ìˆì§€ ì•Šì€ ë™ì•ˆ ìš°ì„ ìˆœìœ„ íì—ì„œ ë…¸ë“œë¥¼ êº¼ë‚´ì„œ í˜„ì¬ ì •ì ìœ¼ë¡œ ì„¤ì •
    while( ! PQ_IsEmpty( PQ ) )
    {
        PQNode  Popped;
        
        PQ_Dequeue(PQ, &Popped);
        CurrentVertex = (Vertex*)Popped.Data;

		// í˜„ì¬ ì •ì ì„ ê°€ì¥ìë¦¬ ë°°ì—´ë¡œ ì„¤ì •
        Fringes[CurrentVertex->Index] = CurrentVertex;

		// í˜„ì¬ ì •ì ê³¼ ì—°ê²°ëœ ê°„ì„ ë“¤ì„ í™•ì¸í•˜ë©° -> ëŒ€ìƒ 'ì •ì 'ì„ ì„¤ì •
        CurrentEdge = CurrentVertex->AdjacencyList;
        while ( CurrentEdge != NULL )
        {            
            Vertex* TargetVertex = CurrentEdge->Target;

			// ëŒ€ìƒ ì •ì ì´ ê°€ì¥ìë¦¬ ë°°ì—´ì— ì†í•˜ì§€ ì•Šê³ , 
			// í˜„ì¬ ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ ëŒ€ìƒ ì •ì ì˜ í˜„ì¬ ìµœì†Œ ê°€ì¤‘ì¹˜ë³´ë‹¤ ì‘ì€ ê²½ìš°, 
			// ëŒ€ìƒ ì •ì ì˜ ê°€ì¤‘ì¹˜ë¥¼ ì—…ë°ì´íŠ¸í•˜ê³  ìš°ì„ ìˆœìœ„ íì— ëŒ€ë¡œìš´ ë…¸ë“œ ì¶”ê°€
            if ( Fringes[TargetVertex->Index] == NULL &&
                 CurrentEdge->Weight < Weights[TargetVertex->Index] )
            {
                PQNode NewNode =  { CurrentEdge->Weight, TargetVertex };
                PQ_Enqueue ( PQ, NewNode );

                Precedences[TargetVertex->Index] = CurrentEdge->From;
                Weights[TargetVertex->Index]     = CurrentEdge->Weight;                
            }
            // í˜„ì¬ ì •ì ê³¼ ì—°ê²°ëœ ëª¨ë“  ê°„ì„  ê²€ì‚¬
            CurrentEdge = CurrentEdge->Next;
        }
    }
	// ì„ í–‰ ì •ì ì„ ì´ìš©í•˜ì—¬ MST êµ¬ì„±
    for ( i=0; i<G->VertexCount; i++ )
    {
        int FromIndex, ToIndex;

        if ( Precedences[i] == NULL )
            continue;

        FromIndex = Precedences[i]->Index;
        ToIndex   = i;

        AddEdge( MSTVertices[FromIndex], 
            CreateEdge( MSTVertices[FromIndex], MSTVertices[ToIndex],   Weights[i] ) );

        AddEdge( MSTVertices[ToIndex],   
            CreateEdge( MSTVertices[ToIndex],   MSTVertices[FromIndex], Weights[i] ) );
    }

	// ë™ì ìœ¼ë¡œ í• ë‹¹ëœ ë©”ëª¨ë¦¬ì™€ ìš°ì„ ìˆœìœ„ íë¥¼ í•´ì œ
    free( Fringes );
    free( Precedences );
    free( MSTVertices );
    free( Weights );

    PQ_Destroy( PQ );
}
```

### í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜(Kruskal's Algorithm)
- ê·¸ë˜í”„ ë‚´ ëª¨ë“  ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ ì •ë³´ë¥¼ ì‚¬ì „ì— íŒŒì•…í•˜ê³  ì´ ì •ë³´ë¥¼ í† ëŒ€ë¡œ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ êµ¬ì¶•
- ëª¨ë“  ê°„ì„ ì„ ê°€ì¤‘ì¹˜ì˜ **ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬**í•˜ì—¬ ëª©ë¡ì„ ë§Œë“¤ê³  ì´ ëª©ë¡ì„ ìˆœíšŒí•˜ë©´ì„œ ê°„ì„ ì„ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ì— ì¶”ê°€ (ì¶”ê°€ëœ ê°„ì„ ìœ¼ë¡œ íŠ¸ë¦¬ ë‚´ì— ì‚¬ì´í´ì´ í˜•ì„±ë˜ë©´ ì•ˆë¨)
- ê° ì •ì ë³„ë¡œ ê°ê°ì˜ **ë¶„ë¦¬ ì§‘í•©**ì„ ë§Œë“¤ê³ , ê°„ì„ ìœ¼ë¡œ ì—°ê²°ëœ ì •ì ë“¤ì— ëŒ€í•´ì„œëŠ” í•©ì§‘í•©ì„ ìˆ˜í–‰ -> <mark style="background: #824CB496;">ê°„ì„ ìœ¼ë¡œ ì—°ê²°í•  ë‘ ì •ì ì´ ê°™ì€ ì§‘í•©ì— ì†í•´ ìˆë‹¤ë©´ ì´ ì—°ê²°ì€ ì‚¬ì´í´ì„ ì´ë£¨ê²Œ ë˜ë¯€ë¡œ ë¬´ì‹œ</mark>
- ![[5-12. í¬ë£¨ìŠ¤ì¹¼ì•Œê³ ë¦¬ì¦˜1.png|550]] 
  ![[5-13. í¬ë£¨ìŠ¤ì¹¼ì•Œê³ ë¦¬ì¦˜2.png|550]]
```c
#include "MST.h"

void Kruskal(Graph* G, Graph* MST )
{
	// í•„ìš”í•œ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ê³  ë©”ëª¨ë¦¬ í• ë‹¹
    int           i;
    Vertex*       CurrentVertex = NULL;
    // MSTì— ì†í•˜ëŠ” ì •ì ì„ ì €ì¥í•  ë°°ì—´
    Vertex**      MSTVertices   = (Vertex**) malloc( sizeof(Vertex*) * G->VertexCount );
    // ê° ì •ì ì˜ ì†í•œ ì§‘í•©ì„ ë‚˜íƒ€ë‚´ëŠ” disjoint-setì„ ì €ì¥í•  ë°°ì—´
    DisjointSet** VertexSet     = 
                         (DisjointSet**)malloc( sizeof(DisjointSet*) * G->VertexCount );
    
    PriorityQueue* PQ      = PQ_Create(10); // ìš°ì„ ìˆœìœ„ í ìƒì„±

    i = 0;    
    // ê·¸ë˜í”„ì˜ ëª¨ë“  ì •ì ì— ëŒ€í•´ ë°˜ë³µ
    CurrentVertex = G->Vertices;
    while ( CurrentVertex != NULL )
    {
	    // í˜„ì¬ ì •ì ì´ ì†í•œ disjoint-setì„ ë§Œë“¤ê³ , MSTì— í•´ë‹¹ ì •ì  ì¶”ê°€
        Edge* CurrentEdge;

        VertexSet[i]   = DS_MakeSet( CurrentVertex );
        MSTVertices[i] = CreateVertex( CurrentVertex->Data );
        AddVertex( MST, MSTVertices[i] );

		// í˜„ì¬ ì •ì ê³¼ ì—°ê²°ëœ ê°„ì„ ì„ ìš°ì„  ìˆœìœ„íì— ì¶”ê°€
        CurrentEdge = CurrentVertex->AdjacencyList;
        while ( CurrentEdge != NULL )
        {
            PQNode NewNode = { CurrentEdge->Weight, CurrentEdge };
            PQ_Enqueue( PQ, NewNode );

            CurrentEdge = CurrentEdge->Next;
        }

        CurrentVertex  = CurrentVertex->Next;        
        i++;
    }

	// ìš°ì„ ìˆœìœ„ íê°€ ë¹„ì–´ìˆì§€ ì•Šì€ ë™ì•ˆ, ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ ì‘ì€ ê°„ì„ ì„ ê°€ì ¸ì™€ì„œ ì¶œë ¥
    while ( !PQ_IsEmpty( PQ ) )
    {
        Edge*  CurrentEdge;
        int    FromIndex;
        int    ToIndex;
        PQNode Popped;

        PQ_Dequeue( PQ, &Popped );
        CurrentEdge = (Edge*)Popped.Data;

        printf("%c - %c : %d\n", 
            CurrentEdge->From->Data, 
            CurrentEdge->Target->Data, 
            CurrentEdge->Weight );

		// í˜„ì¬ ê°„ì„ ì˜ ë‘ ì •ì ì´ ê°™ì€ ì§‘í•©ì— ì†í•´ìˆì§€ ì•Šë‹¤ë©´, 
		// í•´ë‹¹ ê°„ì„ ì„ MSTì— ì¶”ê°€í•˜ê³  ë‘ ì •ì ì´ ì†í•œ disjoint-setì„ í•©ì¹¨
        FromIndex = CurrentEdge->From->Index;
        ToIndex   = CurrentEdge->Target->Index;

        if ( DS_FindSet( VertexSet[FromIndex] ) != DS_FindSet( VertexSet[ToIndex] ) )
        {
            AddEdge( MSTVertices[FromIndex], 
                     CreateEdge( MSTVertices[FromIndex], 
                                 MSTVertices[ToIndex], 
                                 CurrentEdge->Weight ) );

            AddEdge( MSTVertices[ToIndex], 
                     CreateEdge( MSTVertices[ToIndex], 
                                 MSTVertices[FromIndex], 
                                 CurrentEdge->Weight ) );

            DS_UnionSet( VertexSet[FromIndex], VertexSet[ToIndex] );
        }
    }

	// í• ë‹¹í•œ ë©”ëª¨ë¦¬ í•´ì œ
    for ( i=0; i<G->VertexCount; i++ )
        DS_DestroySet( VertexSet[i] );

    free( VertexSet );
    free( MSTVertices );
}
```

***


## ìµœë‹¨ ê²½ë¡œ íƒìƒ‰
- ê·¸ë˜í”„ ë‚´ì˜ í•œ ì •ì ì—ì„œ ë‹¤ë¥¸ ì •ì ìœ¼ë¡œ ì´ë™í•  ë•Œ ê°€ì¤‘ì¹˜ í•©ì´ ìµœì†Ÿê°’ì¸ ê²½ë¡œë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜

### ë°ì´í¬ìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜
- í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ì´ ë‹¨ìˆœíˆ ê°„ì„ ì˜ ê¸¸ì´ë¥¼ ì´ìš©í•˜ì—¬ ì–´ë–¤ ê°„ì„ ì„ ë¨¼ì € ì—°ê²°í• ì§€ ê²°ì •í•˜ëŠ” ë° ë¹„í•´ ë°ì´í¬ìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì€ **ê²½ë¡œì˜ ê¸¸ì´ë¥¼ ê°ì•ˆí•´ì„œ ê°„ì„ ì„ ì—°ê²°**
- ë°ì´ìŠ¤í¬íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì˜ ê²½ìš° ì‚¬ì´í´ì´ ì—†ëŠ” ë°©í–¥ì„± ê·¸ë˜í”„ì— í•œí•´ì„œë§Œ ì‚¬ìš© ê°€ëŠ¥
- (ê·¸ë˜í”„ì—ì„œ ê° ì •ì ì˜ ìƒë‹¨ì— ìˆëŠ” ìƒì ì† ê°’ë“¤ì€ Bì—ì„œ í•´ë‹¹ ì •ì ì— ì´ë¥´ëŠ” ê²½ë¡œìƒ ëª¨ë“  ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ë¥¼ í•©í•œ ê²ƒì˜ ìµœì†Œì¹˜) 
  ![[5-14. ë°ì´í¬ìŠ¤íŠ¸ë¼ì•Œê³ ë¦¬ì¦˜.png|380]]


#ì½”ë“œ  ë°ì´í¬ìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ì€ í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜ê³¼ ë¹„ìŠ·í•œ ë°©ì‹ìœ¼ë¡œ ë™ì‘
> (Graph.h, Graph.c, PriorityQueue.h, PriorityQueue.c, ShortestPath.h, ShortestPath.c, Test_ShortestPath.c)
#### PriorityQueue.h
```c
#ifndef PRIORITYQUEUE_H
#define PRIORITYQUEUE_H

#include <stdio.h>
#include <memory.h>
#include <stdlib.h>

typedef int       PriorityType;

typedef struct tagePQNode 
{
    PriorityType Priority;
    void*        Data;
} PQNode;

typedef struct tagPriorityQueue 
{
    PQNode* Nodes;
    int Capacity;
    int UsedSize;
} PriorityQueue;

PriorityQueue* PQ_Create( int InitialSize );
void           PQ_Destroy( PriorityQueue* PQ );
void           PQ_Enqueue( PriorityQueue* PQ, PQNode NewData );
void           PQ_Dequeue( PriorityQueue* PQ, PQNode* Root );
int            PQ_GetParent( int Index );
int            PQ_GetLeftChild( int Index );
void           PQ_SwapNodes( PriorityQueue* PQ, int Index1, int Index2 );
int            PQ_IsEmpty( PriorityQueue* PQ );

#endif

```
#### PriorityQueue.c
```c
#include "PriorityQueue.h"

PriorityQueue* PQ_Create( int IntitialSize )
{
    PriorityQueue* NewPQ = (PriorityQueue*) malloc( sizeof( PriorityQueue ) );
    NewPQ->Capacity = IntitialSize;
    NewPQ->UsedSize = 0;
    NewPQ->Nodes = (PQNode*) malloc( sizeof ( PQNode ) * NewPQ->Capacity );

    return NewPQ;
}

void  PQ_Destroy( PriorityQueue* PQ )
{
    free( PQ->Nodes );
    free( PQ );
}

void  PQ_Enqueue( PriorityQueue* PQ, PQNode NewNode )
{
    int CurrentPosition = PQ->UsedSize;
    int ParentPosition  = PQ_GetParent( CurrentPosition );

    if ( PQ->UsedSize == PQ->Capacity ) 
    {
        if ( PQ->Capacity == 0 )
            PQ->Capacity = 1;
            
        PQ->Capacity *= 2;
        PQ->Nodes = (PQNode*) realloc( PQ->Nodes, sizeof( PQNode ) * PQ->Capacity );
    }

    PQ->Nodes[CurrentPosition] = NewNode;

    //  í›„ì† ì²˜ë¦¬
    while ( CurrentPosition > 0 
        && PQ->Nodes[CurrentPosition].Priority < PQ->Nodes[ParentPosition].Priority )
    {
        PQ_SwapNodes( PQ, CurrentPosition, ParentPosition );
        
        CurrentPosition = ParentPosition;
        ParentPosition  = PQ_GetParent( CurrentPosition );
    }

    PQ->UsedSize++;
}

void      PQ_SwapNodes( PriorityQueue* PQ, int Index1, int Index2 )
{ 
    int CopySize = sizeof( PQNode );
    PQNode* Temp = (PQNode*)malloc(CopySize);
        
    memcpy( Temp,               &PQ->Nodes[Index1], CopySize);
    memcpy( &PQ->Nodes[Index1] , &PQ->Nodes[Index2], CopySize);
    memcpy( &PQ->Nodes[Index2] , Temp,              CopySize);

    free(Temp);
}

void      PQ_Dequeue( PriorityQueue* PQ, PQNode* Root )
{
    int ParentPosition = 0;
    int LeftPosition   = 0;    
    int RightPosition  = 0;    
    
    memcpy(Root, &PQ->Nodes[0], sizeof(PQNode));
    memset(&PQ->Nodes[0], 0, sizeof(PQNode));

    PQ->UsedSize--;
    PQ_SwapNodes( PQ, 0, PQ->UsedSize );

    LeftPosition  = PQ_GetLeftChild( 0 );
    RightPosition = LeftPosition + 1;

    while ( 1 )
    {
        int SelectedChild = 0;

        if ( LeftPosition >= PQ->UsedSize )
            break;

        if ( RightPosition >= PQ->UsedSize )
        {
            SelectedChild = LeftPosition;
        }
        else {
            if ( PQ->Nodes[LeftPosition].Priority > PQ->Nodes[RightPosition].Priority)
                SelectedChild = RightPosition;
            else
                SelectedChild = LeftPosition;                
        }

        if ( PQ->Nodes[SelectedChild].Priority < PQ->Nodes[ParentPosition].Priority)
        {
            PQ_SwapNodes(PQ, ParentPosition, SelectedChild);
            ParentPosition = SelectedChild;
        }
        else
            break;

        LeftPosition  = PQ_GetLeftChild(ParentPosition);
        RightPosition = LeftPosition + 1;
    }

    if ( PQ->UsedSize < ( PQ->Capacity / 2 ) ) 
    {
        PQ->Capacity /= 2;
        PQ->Nodes = 
            (PQNode*) realloc( PQ->Nodes, sizeof( PQNode ) * PQ->Capacity );
    }
}

int PQ_GetParent( int Index )
{
    return (int) ((Index - 1) / 2);
}

int PQ_GetLeftChild( int Index )
{
    return (2 * Index) + 1;
}

int PQ_IsEmpty( PriorityQueue* PQ )
{
    return ( PQ->UsedSize == 0 );
}

```

#### ShortestPath.h
```c
#ifndef SHORTESTPATH_H
#define SHORTESTPATH_H

#include "Graph.h"
#include "PriorityQueue.h"

#define MAX_WEIGHT 36267

void Dijkstra(Graph* G, Vertex* StartVertex, Graph* MST );

#endif

```
#### ShortestPath.c
```c
#include "ShortestPath.h"

void Dijkstra(Graph* G, Vertex* StartVertex, Graph* ShortestPath )
{
    int i = 0;

	// ì‹œì‘ ì •ì ê³¼ ê°€ì¤‘ì¹˜ 0ìœ¼ë¡œ êµ¬ì„±ëœ ìš°ì„ ìˆœìœ„ í ë…¸ë“œ&í ìƒì„±
    PQNode         StartNode = { 0, StartVertex };
    PriorityQueue* PQ        = PQ_Create(10);

    Vertex*  CurrentVertex = NULL;
    Edge*    CurrentEdge   = NULL; 

    int*     Weights       = (int*) malloc( sizeof(int) * G->VertexCount );
    Vertex** ShortestPathVertices = 
                             (Vertex**) malloc( sizeof(Vertex*) * G->VertexCount );
    Vertex** Fringes       = (Vertex**) malloc( sizeof(Vertex*) * G->VertexCount );
    Vertex** Precedences   = (Vertex**) malloc( sizeof(Vertex*) * G->VertexCount );

	// í˜„ì¬ ì •ì ì„ ê·¸ë˜í”„ì˜ ì²« ë²ˆì§¸ ì •ì ìœ¼ë¡œ ì´ˆê¸°í™”í•˜ê³  ëª¨ë“  ì •ì ì— ëŒ€í•´ ë°˜ë³µ
    CurrentVertex = G->Vertices;
    while ( CurrentVertex != NULL )
    {
        Vertex* NewVertex = CreateVertex( CurrentVertex->Data );
        AddVertex( ShortestPath, NewVertex);

        Fringes[i]     = NULL;
        Precedences[i] = NULL;
        ShortestPathVertices[i] = NewVertex;        
        Weights[i]     = MAX_WEIGHT;        
        CurrentVertex  = CurrentVertex->Next;
        i++;
    }

	// ì‹œì‘ ì •ì ì„ ìš°ì„ ìˆœìœ„ íì— ì¶”ê°€í•˜ê³  ì‹œì‘ ì •ì ì˜ ê°€ì¤‘ì¹˜ë¥¼ 0ìœ¼ë¡œ ì„¤ì •
    PQ_Enqueue ( PQ, StartNode );

    Weights[StartVertex->Index] = 0;

	// ìš°ì„ ìˆœìœ„ íê°€ ë¹„ì–´ìˆì§€ ì•Šì€ ë™ì•ˆ, 
	// ìš°ì„ ìˆœìœ„ íì—ì„œ ì •ì ì„ ê°€ì ¸ì™€ í•´ë‹¹ ì ì •ê³¼ ì—°ê²°ëœ ê°„ì„ ë“¤ì„ ê²€ì‚¬í•˜ê³  ìµœë‹¨ ê²½ë¡œë¥¼ ì—…ë°ì´íŠ¸
    while( ! PQ_IsEmpty( PQ ) )
    {
        PQNode  Popped;
        
        PQ_Dequeue(PQ, &Popped);
        CurrentVertex = (Vertex*)Popped.Data;
        
        Fringes[CurrentVertex->Index] = CurrentVertex;

        CurrentEdge = CurrentVertex->AdjacencyList;
        while ( CurrentEdge != NULL )
        {            
            Vertex* TargetVertex = CurrentEdge->Target;

            if ( Fringes[TargetVertex->Index] == NULL &&
                 Weights[CurrentVertex->Index] + CurrentEdge->Weight < 
                               Weights[TargetVertex->Index] )
            {
                PQNode NewNode =  { CurrentEdge->Weight, TargetVertex };
                PQ_Enqueue ( PQ, NewNode );

                Precedences[TargetVertex->Index] =  CurrentEdge->From;
                Weights[TargetVertex->Index]     =  
                               Weights[CurrentVertex->Index] + CurrentEdge->Weight; 
            }
            
            CurrentEdge = CurrentEdge->Next;
        }
    }

	// ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬ì„±í•˜ëŠ” ê°„ì„ ë“¤ì„ ìµœë‹¨ ê²½ë¡œ ê·¸ë˜í”„ì— ì¶”ê°€
    for ( i=0; i<G->VertexCount; i++ )
    {
        int FromIndex, ToIndex;

        if ( Precedences[i] == NULL )
            continue;

        FromIndex = Precedences[i]->Index;
        ToIndex   = i;

        AddEdge( ShortestPathVertices[FromIndex], 
            CreateEdge( 
                ShortestPathVertices[FromIndex], 
                ShortestPathVertices[ToIndex],   
                Weights[i] ) );
    }

	// í• ë‹¹ëœ ë©”ëª¨ë¦¬ë¥¼ í•´ì œí•˜ê³  ìš°ì„ ìˆœìœ„ íë¥¼ íŒŒê´´
    free( Fringes );
    free( Precedences );
    free( ShortestPathVertices );
    free( Weights );

    PQ_Destroy( PQ );
}
```
#### Test_ShortestPath.c
```c
#include "Graph.h"
#include "ShortestPath.h"

int main( void )
{
    
    //  ê·¸ë˜í”„ ìƒì„±     
    Graph* graph      = CreateGraph();
    Graph* PrimMST    = CreateGraph();
    Graph* KruskalMST = CreateGraph();
   
    //  ì •ì  ìƒì„± 
    Vertex* A = CreateVertex( 'A' );
    Vertex* B = CreateVertex( 'B' );
    Vertex* C = CreateVertex( 'C' );
    Vertex* D = CreateVertex( 'D' );
    Vertex* E = CreateVertex( 'E' );
    Vertex* F = CreateVertex( 'F' );
    Vertex* G = CreateVertex( 'G' );
    Vertex* H = CreateVertex( 'H' );
    Vertex* I = CreateVertex( 'I' );

    //  ê·¸ë˜í”„ì— ì •ì ì„ ì¶”ê°€ 
    AddVertex( graph, A );
    AddVertex( graph, B );
    AddVertex( graph, C );
    AddVertex( graph, D );
    AddVertex( graph, E );
    AddVertex( graph, F );
    AddVertex( graph, G );
    AddVertex( graph, H );
    AddVertex( graph, I );

    //  ì •ì ê³¼ ì •ì ì„ ê°„ì„ ìœ¼ë¡œ ì‡ê¸° 
    
    AddEdge( A, CreateEdge(A, E, 247) );

    AddEdge( B, CreateEdge(B, A, 35  ) );
    AddEdge( B, CreateEdge(B, C, 126 ) );
    AddEdge( B, CreateEdge(B, F, 150 ) );
    
    AddEdge( C, CreateEdge(C, D, 117 ) );
    AddEdge( C, CreateEdge(C, F, 162 ) );
    AddEdge( C, CreateEdge(C, G, 220 ) );
    
    AddEdge( E, CreateEdge(E, H, 98 ) );

    AddEdge( F, CreateEdge(F, E, 82  ) );
    AddEdge( F, CreateEdge(F, G, 154 ) );
    AddEdge( F, CreateEdge(F, H, 120 ) );

    AddEdge( G, CreateEdge(G, I, 106 ) );

    //  ì •ì  Bë¥¼ ì‹œì‘ ì •ì ìœ¼ë¡œ í•˜ëŠ” ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬
    Dijkstra(graph, B, PrimMST);
    PrintGraph ( PrimMST );
    
    //  ê·¸ë˜í”„ ì†Œë©¸ 
    DestroyGraph( PrimMST );
    DestroyGraph( KruskalMST );
    DestroyGraph( graph );

    return 0;
}
```
![[5-15. ShortestPathResult.png]]