## ëŒë‹¤ (lambda)
- í•¨ìˆ˜ ê°ì²´(functor)ë¥¼ ë¹ ë¥´ê²Œ ë§Œë“œëŠ” ë¬¸ë²•ì´ë‹¤ (í•¨ìˆ˜ ê°ì²´ëŠ” í˜¸ì¶œ ì—°ì‚°ì(())ì™€ í•¨ê»˜ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ê°ì²´)
- í•¨ìˆ˜ ê°ì²´ë¥¼ ì´ìš©í•˜ë©´ í•˜ë‚˜ì˜ í•¨ìˆ˜ë§Œ ì‹¤í–‰í•˜ëŠ” ê²Œ ì•„ë‹ˆë¼ ì›í•˜ëŠ” ë°ì´í„°ë„ ì´ë¦¬ì €ë¦¬ ë„£ì–´ì¤„ ìˆ˜ ìˆë‹¤
- `[ìº¡ì³](ì¸ìê°’) { êµ¬í˜„ë¶€ }`

```cpp
enum class ItemType
{
	None,
	Armor,
	Weapon,
	Jewelry,
	Consumable
};

enum class Rarity
{
	Common,
	Rare, 
	Unique
};

class Item
{
public:
	Item() { }
	Item(int itemId, Rarity rarity, ItemType type)
		: _itemId(itemId), _rarity(rarity), _type(type)
	{

	}

public:
	int _itemId = 0;
	Rarity _rarity = Rarity::Common;
	ItemType _type = ItemType::None;
};

int main()
{
	vector<Item> v;
	v.push_back(Item(1, Rarity::Common, ItemType::Weapon));
	v.push_back(Item(2, Rarity::Common, ItemType::Armor));
	v.push_back(Item(3, Rarity::Rare, ItemType::Jewelry));
	v.push_back(Item(4, Rarity::Unique, ItemType::Weapon));

	// ëŒë‹¤ = í•¨ìˆ˜ ê°ì²´ë¥¼ ì†ì‰½ê²Œ ë§Œë“œëŠ” ë¬¸ë²•
	// ëŒë‹¤ ìì²´ë¡œ C++11ì— 'ìƒˆë¡œìš´' ê¸°ëŠ¥ì´ ë“¤ì–´ê°„ ê²ƒì€ ì•„ë‹ˆë‹¤
	{
		struct IsUniqueItem
		{
			bool operator()(Item& item)
			{
				return item._rarity == Rarity::Unique;
			}
		};

		// í´ë¡œì € (closure) = ëŒë‹¤ì— ì˜í•´ ë§Œë“¤ì–´ì§„ ì‹¤í–‰ì‹œì  ê°ì²´
		auto isUniqueLamda = [](Item& item) 
		{ 
				return item._rarity == Rarity::Unique;  
		}; // ëŒë‹¤ í‘œí˜„ì‹(lamda expression)

		//auto findIt = std::find_if(v.begin(), v.end(), IsUniqueItem()); // ì¤‘ìš”!
		auto findIt = std::find_if(v.begin(), v.end(), isUniqueLamda);	  // ìœ„ì™€ ë™ì¼í•˜ê²Œ ë™ì‘
		if (findIt != v.end())
			cout << "ì•„ì´í…œID: " << findIt->_itemId << endl;
	}

	{
		struct FindItem
		{
			FindItem(int itemId, Rarity rarity, ItemType type)
				: _itemId(itemId), _rarity(rarity), _type(type)
			{

			}

			bool operator()(Item& item)
			{
				return item._itemId == _itemId && item._rarity == _rarity && item._type == _type;
			}

			int _itemId;
			Rarity _rarity;
			ItemType _type;
		};

		int itemId = 4;
		Rarity rarity = Rarity::Unique;
		ItemType type = ItemType::Weapon;

		// [ ] ìº¡ì³(capture) : í•¨ìˆ˜ ê°ì²´ ë‚´ë¶€ì— ë³€ìˆ˜ë¥¼ ì €ì¥í•˜ëŠ” ê°œë…ê³¼ ìœ ì‚¬
		// í•¨ìˆ˜ ê°ì²´ì—ì„œëŠ” ë‚´ë¶€ì—ë§Œ ìˆëŠ” ì• ë¥¼ ì“¸ ìˆ˜ ìˆì—ˆëŠ”ë° ëŒë‹¤ì—ì„œëŠ” ë°–ì— ìˆëŠ” ì• ë¥¼ ê·¸ëƒ¥ ì‚¬ìš© ê°€ëŠ¥
		// ì‚¬ì§„ì„ ì°°ì¹µ [ìº¡ì³]í•˜ë“¯... ì¼ì¢…ì˜ ìŠ¤ëƒ…ìƒ·ì„ ì°ëŠ”ë‹¤ê³  ì´í•´
		// ê¸°ë³¸ ìº¡ì³ ëª¨ë“œ : ê°’(ë³µì‚¬) ë°©ì‹(=) or ì°¸ì¡° ë°©ì‹(&)
		// C++ì—ì„œëŠ” ëª¨ë“  ì• ë“¤ì„ ë³µì‚¬í•˜ê±°ë‚˜ ì°¸ì¡° ë°©ì‹ìœ¼ë¡œ ë„£ì–´ì£¼ëŠ” ê²ƒì„ ì§€ì–‘!!! (ì–´ë–¤ ì• ë“¤ì´ ìº¡ì³ê°€ ë˜ì–´ ë‚´ë¶€ë¡œ ë“¤ì–´ê°”ëŠ”ì§€ ì•Œê¸° í˜ë“¬) ğŸ”¥
		// auto findByItem = [=](Item& item) 
		// ë³µì‚¬ ë°©ì‹ì„ ì“°ë©´ functorì„ ë§Œë“¤ ë•Œ ì²˜ëŸ¼ í•˜ë‚˜í•˜ë‚˜ ì¸ìë¥¼ ë„£ì–´ì¤„ í•„ìš” ì—†ì´ ëª¨ë“  ë¶€ë¶„ì„ ë°–ì—ì„œ êº¼ë‚´ì“¸ ìˆ˜ ìˆë‹¤ ğŸ”¥
		// ì°¸ì¡° ë°©ì‹ìœ¼ë¡œ ë„˜ê²¨ì¤„ ë•ŒëŠ” ì•„ì´í…œì„ ì‚¬ìš©í•  ë•Œê¹Œì§€ ì°¸ì¡°ê°’ì´ ìœ íš¨í•´ì•¼í•˜ë¯€ë¡œ ë©”ëª¨ë¦¬ê°€ ë‚ ì•„ê°€ë©´ ë™ì‘ì„ ëª»í•˜ëŠ” ìƒí™©ì´ ì¼ì–´ë‚  ìˆ˜ ìˆìœ¼ë‹ˆ ì£¼ì˜!
		// ë³€ìˆ˜ë§ˆë‹¤ ìº¡ì³ ëª¨ë“œë¥¼ ì§€ì •í•´ì„œ ì‚¬ìš©ì´ ê°€ëŠ¥ : ê°’ ë°©ì‹(name) or ì°¸ì¡° ë°©ì‹(&name)
		auto findByItem = [itemId, rarity, &type](Item& item) 
		{ 
			return item._itemId == itemId && item._rarity == rarity && item._type == type;
		};

		//itemId = 10;  // ìº¡ì³ëª¨ë“œë¥¼ ì°¸ì¡° ë°©ì‹ìœ¼ë¡œ í–ˆì„ ë•Œ ê°’ ë³€ê²½ ê°€ëŠ¥

		//auto findIt = std::find_if(v.begin(), v.end(), FindItem(itemId, rarity, type));
		auto findIt = std::find_if(v.begin(), v.end(), findByItem);

		if (findIt != v.end())
			cout << "ì•„ì´í…œID: " << findIt->_itemId << endl;
	}

	// ë³µì‚¬ ë°©ì‹ìœ¼ë¡œ ë§Œë“¤ì—ˆì„ ë•Œ ì˜ˆìƒì¹˜ë„ ëª»í•œ ë²„ê·¸ê°€ ë°œìƒí•˜ëŠ” ê²½ìš°
	{
		class Knight
		{
		public:
			auto ResetHpJob()
			{
				auto f = [=]() 
				{
					_hp = 200;
					// ì—¬ê¸°ì„œ ë³µì‚¬ëœ ê²ƒì€ _hpê°€ ì•„ë‹ˆë‹¤
					// this->_hp = 200 this(Knightê°ì²´ì£¼ì†Œ) í¬ì¸í„°ê°€ ìƒëµì´ ë˜ì–´ìˆë‹¤
				};

				return f;
			}

		public:
			int _hp = 100;
		};

		Knight* k = new Knight();
		auto job = k->ResetHpJob();
		delete k;
		job();	// ì´ë¯¸ ë‚ ì•„ê°„ ë©”ëª¨ë¦¬ë¥¼ ê³ ì¹˜ëŠ” ì—‰ëš±í•œ ì§“..
	}

	return 0;
}
```