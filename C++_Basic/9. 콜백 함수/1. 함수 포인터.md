## 함수 포인터 😡
- 포인터 주소를 타고 가면 함수가 있는 형태
- 어떤 기능, 동작 자체를 함수에 넘기고 싶을 때 사용
```cpp
int Add(int a, int b)
{
	return a + b;
}

class Item
{
public:
	Item() : _itemid(0), _rarity(0), _ownerId(0)
	{

	}

public:
	int _itemid;	// 아이템 구분을 위한 id
	int _rarity;	// 희귀도
	int _ownerId;	// 소지자 ID
};

// 인벤토리에서 아이템 찾을 때 여러 조건이 있으므로 그 조건을 다 이 안에 넣으면 너무 커짐
// 그래서 함수 포인터를 사용하여 필요할 때 특정 함수를 불러오는	방식
typedef bool(ITEM_SELECTOR)(Item*, int);
Item* FindItem(Item items[], int itemCount, ITEM_SELECTOR* selector, int value)
{
	for (int i = 0; i < itemCount; i++)
	{
		Item* item = &items[i];
		if (selector(item, value))
			return item;
	}
	return nullptr;
}

bool IsRareItem(Item* item, int value)
{
	return item->_rarity >= value;
}

bool IsOwnerItem(Item* item, int ownerId)
{
	return item->_ownerId == ownerId;
}

int main()
{
	int a = 10;
	typedef int DATA;
	DATA* pointer = &a;

	// "포인터를 타고 가면 (데이터 타입)함수가 있어요"를 어떻게 표현할까? -> 함수 포인터
	typedef int(FUNC_TYPE)(int a, int b);  //using FUNC_TYPE = int(int a, int b);와 동일
	FUNC_TYPE* fn;

	// 함수의 이름(Add)은 함수의 시작 주소 (배열과 유사)
	fn = Add;	// 시그니처가 동일한 함수의 주소를 담을 수 있음

	int result = fn(1, 2);	// 기본 문법
	cout << result << endl;

	result = (*fn)(1, 2);	// 함수 포인터는 *(접근 연산자) 붙여도 함수 주소
	cout << result << endl;
	

	Item items[10] = {};
	items[3]._rarity = 2;
	Item* rareItem = FindItem(items, 10, IsRareItem, 2);

	return 0;
}
```

***

### 멤버 함수 호출 문법
```cpp
#include <iostream>
using namespace std;

// typedef의 진실
// typedef 왼쪽 오른값 -> 오른쪽(커스텀 타입 정의)
// 정확히는 왼쪽/오른쪽 기준이 아니라,
// [선언 문법]에서 typedef을 앞에다 붙이는 쪽

class Knight
{
public:
	static void HelloKnight()
	{

	}
	// 멤버 함수
	int GetHp(int, int)
	{
		cout << "GetHp()" << endl;
		return _hp;
	}
public:
	int _hp = 100;
};

typedef int INTRGER;
typedef int* POINTER;
//typedef int FUNC();
typedef int ARRAY[20];
typedef int(*PFUNC)(int, int);	// 함수 포인터
typedef int(Knight::*PMEMFUNC)(int, int); // 멤버 함수 포인터

int Test(int a, int b)
{
	cout << "Test" << endl;
	return a + b;
}

int t(int a, int b)
{
	cout << "t" << endl;
	return a + b;
}

int main()
{
	//int (*fn)(int, int);
	//fn = &Test; // & 생략 가능 (c언어 호환성 때문)
	//fn(1, 2);
	//(*fn)(1, 2);

	// 메모리에 올라가는 개념이 아니라 함수를 타고 가면 구현부가 있을 것이다라는 선언에 불과함
	//FUNC t;
	PFUNC fn;

	// 위 문법으로 [전역 함수 / 정적 함수]만 담을 수 있다 (호출 규약이 동일한 애들)
	// 멤버 함수는 객체를 기반으로 호출하는 애들
	//fn = &Knight::GetHp;
	Knight k1;
	PMEMFUNC mfn;
	mfn = &Knight::GetHp;
	(k1.*mfn)(1, 1);

	Knight* k2 = new Knight();
	(k2->*mfn)(1, 1);		//((*k2).*mfn)(1, 1);
	delete k2;

	return 0;
}
```