## 콜백
- #콜백 (Callback) : 다시 호출하다? 역으로 호출하다?
- 게임을 만들 때 이런 콜백의 개념이 자주 등장한다
- 어떤 상황이 일어나면 이 기능을 호출해줘 -> 스킬 버튼을 누르면 스킬을 쓰는 함수 호출
- 조건을 직접적으로 넘겨주는 방식으로 코딩 가능

```cpp
#include <iostream>
using namespace std;

class Item
{
public:

public:
    int _itemId = 0;
    int _rarity = 0;
    int _ownerId = 0;
};

class FindByOwnerId
{
public:
    bool operator()(const Item* item)
    {
        return (item->_ownerId == _ownerId);
    }

public:
    int _ownerId;
};

class FindByRarity
{
public:
    bool operator()(const Item* item)
    {
        return (item->_rarity == _rarity);
    }

public:
    int _rarity;
};

template<typename T>
// Item* FindItem(Item items[], int itemCount, bool(*func)(const Item*))
// 함수 포인터를 넘겨주는 방식으로 만들면 간단한 형태로 콜백을 구현할 수 있다는 장점이 있지만
// 상태를 저장할 수 없다는 큰 단점이 있음
// 특정 조건을 체크하는건 상관이 없는데 아이템 아이디를 건네줄 수 없다는 한계
Item* FindItem(Item items[], int itemCount, T selector)
{
    for (int i = 0; i < itemCount; i++)
    {
        Item* item = &items[i];
        if (selector(item))
            return item;
    }
    return nullptr;
}



int main()
{
    Item items[10];
    items[3]._ownerId = 100;
    items[8]._rarity = 2;

    FindByOwnerId functor1;
    functor1._ownerId = 100;

    FindByRarity functor2;
    functor2._rarity = 1;

    Item* item1 = FindItem(items, 10, functor1);
    Item* item2 = FindItem(items, 10, functor2);

    return 0;
}


```
