## 객체 지향 vs 절차 지향
1.  절차 지향 프로그래밍
	- 모든 주체가 함수 (모든 게임 로직이 함수의 흐름대로 실행)
	- 게임이 RPG 처럼 커지면 한계가 있음
2. 객체 지향 프로그래밍
	- 객체란 게임에 존재하는 모든 오브젝트 (플레이어, 몬스터, GameRoom...)
	- **모든 것을 객체(오브젝트) 중심으로 생각**
	- 함수가 객체에 소속되어 있는 느낌으로 만듬

`전에는 로비에 들어가고 몬스터를 만나고 전투를 하는 작업이 순서대로 이루어지는 절차지향이었다면 객체지향은 객체안에 변수와 함수를 넣고 객체 단위로 생각`

## 객체 지향 프로그래밍 #OOP (Object Oriented Programming)
- C++에서 struct 구조체와 class는 종이 한 장 차이로 거의 똑같음
- 명시되지 않은 경우, struct 의 모든 멤버는 public으로 default, class 의 모든 멤버는 private로 default
- class 라는 **설계도** 안에 **데이터 + 기능**이 같이 들어있음
- 객체 지향 프로그래밍은 현실에 존재하는 사물과 대상, 그리고 그에 따른 행동을 있는 그대로 실체화 시키는 형태의 프로그래밍
- 기능을 관련 있는 데이터에 종속시켜 누구나 쉽게 호출할 수 없도록 함 
- 구조체에서 <mark style="background: #0E4F9FA6;">데이터들은 생성 및 소멸 시점이 일치하고 이동 및 전달의 시점 및 방법이 일치하기 때문에 프로그램의 구현 및 관리 용이</mark> 이런 구조체 안에 함수를 넣어 놓은 것이 클래스
- class의 멤버 함수 내에서 멤버 변수에 접근 가능 (ex. hp)
- 클래스 안에 enum 선언을 둠으로써 잘못된 외부의 접근을 제한할 수 있다
- k1과 k2 데이터는 완전히 다른 채로 공존
- 아래 사진을 보면 class에 멤버 함수와 멤버 변수를 모아 놨지만 막상 보면 메모리에는 멤버 변수만 올라가 있고 **함수들은 메모리에 따로 잡혀있지 않음** -> (C++에서 클래스의 멤버 함수는 클래스의 모든 객체 인스턴스에 대해 "공유"되며, "클래스의 정의를 통해 한 번만 메모리에 로드"됩니다. 이러한 구조는 메모리 사용의 효율성과 유지 보수성을 제공하며, 객체 지향 설계의 일관성을 유지합니다.)
- 일반 함수와 멤버 함수 차이는 &k1 을 스택에 푸쉬 후 넘겨주느냐, 레지스터에 들고 있는 상태로 넘겨주느냐 차이 -> 자기 주소를 넘겨주기 때문에 멤버함수 내부에서는 자신의 정보를 수정 가능,  멤버 함수도 포인터를 넘겨줘서 주소를 이용해 접근하는 문법이랑 별 차이는 없음
- 멤버 함수 내부에서 자기 자신을 가리키고 싶을 때 this 사용 (자신을 가리키는 포인터)
- <mark style="background: #0E4F9FA6;">이제 함수가 어디 동떨어져서 여기다가 그냥 나이트를 넣어주고 그 다음에 걔를 설정할 거예요 (포인터가 뭘 하려는 건지 명확하지 않음)가 아니라 진짜 어떤 함수가 특정 객체에 소속되어 있는 느낌(주체가 되어 움직임)으로 만들기</mark> `k1.Move(2, 2);`
```cpp
// 데이터 + 가공(로직, 동작)
// Knight를 설계해보자
// - 속성(데이터): hp, attack, position(x, y)
// - 기능(동작):Move, Attack, Die

class Knight
{
public:
	// 멤버 함수
	void Move(int y, int x);
	void Attack();
	void Die()  // 간단한 경우 클래스 안에 구현하기도 함
	{
		m_hp = 0;
		cout << "Die" << endl;
	}

public:
	// 멤버 변수
	int m_hp;
	int m_attack;
	int m_posY;
	int m_posX;
};

void Move(Knight* knight, int y, int x) // 절차 지향
{
	knight->m_posY = y;
	knight->m_posX = x;
}

void Knight::Move(int y, int x) // 객체 지향 (Knight안에 있는 Move 함수)
{
	m_posY = y;   // this = *knight, m_posY=this->m_posY
	m_posX = x;
	cout << "Move" << endl;
}

void Knight::Attack()
{
	cout << "Attack : " << m_attack << endl;
}

// Instantiate 객체를 만든다!
int main()
{
	Knight k1;
	k1.m_hp = 100;
	k1.m_attack = 10;
	k1.m_posY = 0;
	k1.m_posX = 0;

	Knight k2;
	k2.m_hp = 80;
	k2.m_attack = 5;
	k2.m_posY = 1;
	k2.m_posX = 1;

	Move(&k1, 2, 2);  // 자체 함수는 객체와 독립적으로 실행 (knight를 포인터로 넘겨줘야함)

	k1.Move(2, 2);
	k1.Attack();
	k1.Die();

	return 0;
}
```
- ![[일반함수vs멤버함수.png]]
