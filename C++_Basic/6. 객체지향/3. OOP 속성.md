## 상속성
- #상속성 (Inheritance)
- 상속된 자식 클래스에서 변수를 선언하면 그 변수는 부모 변수의 메모리
- 부모 클래스 생성자 호출 -> 자식 클래스 생성자 호출 -> 자식 클래스 소멸자 호출 -> 부모 클래스 소멸자 호출
- 모든 것을 객체 단위로 생각을 하다 보니까 객체 사이 계층 관계를 만들어주다가 공통적인 코드는 위로 올려서 관리
- 상속을 받으면 부모의 기능은 다 사용할 수 있고 원하면 재정의 해서 사용 가능
- 예시
	- GameObject: Creature / Player, Monster, Npc, Pet / Projectile / Arrow, Fireball / Env
	- Item: Weapon / Sword, Bow / Armor / Helmet, Boots, Armer / Consumable / Potion, Scroll
```
class Player
{
public:
	Player()
	{
		m_hp = 0;
		m_attack = 0;
		m_defence = 0;
		cout << "Player() 기본 생성자 호출" << endl;
	}

	~Player()
	{
		cout << "Player() 소멸자 호출" << endl;
	}

	void Move() { cout << "Player Move 호출" << endl; }
	void Attack() { cout << "Player Attack 호출" << endl; }
	void Die() { cout << "Player Die 호출" << endl; }

public:
	int m_hp;
	int m_attack;
	int m_defence;
};

class Knight : public Player
{
public:
	Knight()
		/*
		선(먼저)처리 영역
		- 여기서 Player() 생성자를 호출
		*/
	{
		m_stamina = 100;
		cout << "Knight() 기본 생성자 호출" << endl;
	}

	~Knight()
	{
		cout << "Knight() 소멸자 호출" << endl;
	}

	/*
		후(나중에)처리 영역
		- 여기서 ~Player() 소멸자를 호출
	*/

	void Move() { cout << "Knight Move 호출" << endl; }	// 재정의
public:
	int m_stamina;
};

class Mage : public Player
{
public:
	int m_mp;
};

// Instantiate 객체를 만든다!
int main()
{
	Knight k;
	k.m_hp = 100;
	k.Move();
	k.Player::Move();

	return 0;
}
```


***

## 은닉성
- #은닉성 (Data Hiding) = 캡슐화 (Encapsulation)
- 몰라도 되는 것은 깔끔하게 숨기겠다 그 이유는?
- 







***

## 다형성
- #다형성