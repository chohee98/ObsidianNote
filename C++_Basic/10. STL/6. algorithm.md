### ì•ì˜ ì—°ìŠµë¬¸ì œ
- ì•„ë˜ì˜ ì½”ë“œëŠ” ë²¡í„° í•œì •ì ìœ¼ë¡œ ë™ì‘í•˜ë©° ì½”ë“œê°€ ê¸¸ì–´ì ¸ì„œ ì–´ë–¤ ë™ì‘ì„ í•˜ëŠ”ì§€ í•œë²ˆì— ì•Œì•„ë³´ê¸° í˜ë“¤ë‹¤ëŠ” ë‹¨ì ì´ ìˆë‹¤
```cpp
int main()
{
	srand(static_cast<unsigned int>(time(nullptr)));

	vector<int> v;

	for (int i = 0; i < 100; i++)
	{
		int num = rand() % 100;
		v.push_back(num);
	}

	// Q1) number ìˆ«ìê°€ ë²¡í„°ì— ì²´í¬í•˜ëŠ” ê¸°ëŠ¥ (bool, ì²« ë“±ì¥ iterator)
	{
		int number = 50;
		bool found = false;
		vector<int>::iterator it;

		it = v.end();
		for (unsigned int i = 0; i < v.size(); i++)
		{
			int data = v[i];
			if (data == number)
			{
				found = true;
				it = v.begin() + i;
				break;
			}
		}		
	}

	// Q2) ë²¡í„°ì— ë“¤ì–´ê°€ ìˆëŠ” ëª¨ë“  ìˆ«ìë“¤ì— 3ì„ ê³±í•´ì£¼ì„¸ìš”!
	{
		for (unsigned int i = 0; i < v.size(); i++)
		{
			v[i] *= 3;
		}
	}

	return 0;
}
```

***


## ì•Œê³ ë¦¬ì¦˜ (Algorithm)
- ìœ„ì˜ ì—°ìŠµ ë¬¸ì œë¥¼ ì¡°ê¸ˆ ë” ê°€ë…ì„±ì„ ë†’ì—¬ íš¨ìœ¨ì ìœ¼ë¡œ ë§Œë“œëŠ” ê²ƒì´ ì•Œê³ ë¦¬ì¦˜ì´ë‹¤
- ì¦‰ ì•Œê³ ë¦¬ì¦˜ì€ ìë£Œ êµ¬ì¡°ë¥¼ í™œìš©í•´ ì €ì¥í•œ ë°ì´í„°ì— ì ‘ê·¼í•˜ì—¬ ì–´ë–»ê²Œ ì‚¬ìš©í•  ê²ƒ ì¸ì§€ì— ëŒ€í•œ ë°©ë²•ë“¤ì„ ì •ë¦¬í•´ ë†“ì€ ê²ƒì´ë‹¤

### find, find_if
```cpp
// find: ì¼ì¹˜í•˜ëŠ” ê°’ ì°¾ê¸°(ì–´ë””ë¶€í„° ì–´ë””ê¹Œì§€ ë¬´ì—‡ì„ ì°¾ëŠ”ê°€)
vector<int>::iterator itFind = find(v.begin(), v.end(), number);
if (itFind == v.end())
	cout << "ëª»ì°¾ì•˜ìŒ" << endl;
else
	cout << "ì°¾ì•˜ìŒ" << endl;


// í•¨ìˆ˜ ê°ì²´ ìƒì„± -> ì¶”í›„ì—” ëŒë‹¤ì‹ìœ¼ë¡œ ê°„í¸í•˜ê²Œ ë§Œë“¤ ìˆ˜ ìˆìŒ.
// ëŒë‹¤ì‹ : [](int n) { return n % 11 == 0; }
struct CanDivideBy11 
{
    bool operator()(int n) 
    {
        return n % 11 == 0;
    }
};
// find_if: ì¡°ê±´ì— ì¼ì¹˜í•˜ëŠ” ê°’ ì°¾ê¸°
vector<int>::iterator itFind = find_if(v.begin(), v.end(), CanDivideBy11()); // ì²« ë°ì´í„°
```

### cout, count_if, all_of, any_of, none_of
```cpp
// count: ì¼ì¹˜í•˜ëŠ” ê°’ì´ë©´ 1 ì¦ê°€, ëˆ„ì  ì¹´ìš´íŠ¸ ë°˜í™˜
int count = count(v.begin(), v.end(), 4);

// count_if: ì¡°ê±´ì— ì¼ì¹˜í•˜ëŠ” ê°’ì´ë©´ 1 ì¦ê°€
struct IsOdd 
{
    bool operator()(int n) 
    {
        return n % 2 != 0;
    }
};
int n = count_if(v.begin(), v.end(), IsOdd());

// all_of: ëª¨ë“  ë°ì´í„°ê°€ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ”ê°€?
// any_of: ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ë°ì´í„°ê°€ í•˜ë‚˜ë¼ë„ ì¡´ì¬í•˜ëŠ”ê°€?
// none_of: ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ë°ì´í„°ê°€ í•˜ë‚˜ë„ ì—†ëŠ”ê°€?
bool b1 = all_of(v.begin(), v.end(), IsOdd());
bool b2 = any_of(v.begin(), v.end(), IsOdd());
bool b3 = none_of(v.begin(), v.end(), IsOdd());
```

### for_each
```cpp
// for_each: ëª¨ë“  ë°ì´í„° ìŠ¤ìº” ì‹œ ì‚¬ìš©
struct MultiplyBy3 
{
    void operator()(int& n) 
    {
        n *= 3;
        // ì¶œë ¥ê¹Œì§€ í•˜ê³  ì‹¶ìœ¼ë©´
        cout << n << endl;
    }
};
for_each(v.begin(), v.end(), MultiplyBy3());
```

### remove, remove_if (ì£¼ì˜)
```cpp
// ì´í„°ë ˆì´í„°ë¡œ ë£¨í”„ë¥¼ ëŒ ë•Œ ë²¡í„° ìì²´ë¥¼ ê±´ë“œë¦¬ëŠ” í–‰ìœ„ëŠ” ìœ„í—˜í•˜ë¯€ë¡œ ì£¼ì˜í•˜ì
vector<int> v;

v.push_back(1);
v.push_back(4);
v.push_back(3);
v.push_back(5);
v.push_back(8);
v.push_back(2);

// remove: ì¼ì¹˜í•˜ëŠ” ê°’ ì‚­ì œ (ë¶ˆí•„ìš”í•œ ë°ì´í„°ë¥¼ ì‚­ì œí•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ í•„ìš”í•œ ë°ì´í„°ë¥¼ ë‚¨ê²¨ë‘”ë‹¤)
v.erase(remove(v.begin(), v.end(), 4), v.end());

// remove_if: ì¡°ê±´ì— ì¼ì¹˜í•˜ëŠ” ê°’ ì‚­ì œ
/*template<class ForwardIt, class UnaryPredicate>
ForwardIt remove_if(ForwardIt first, ForwardIt last, UnaryPredicate p)
{
	first = std::find_if(first, last, p);
	if (first != last)
		for (ForwardIt i = first; ++i != last; )
			if (!p(*i))
				*first++ = std::move(*i);
	return first;
}*/

// 1 4 3 5 8 2
// 4 8 2 5 8 2  (4 8 2 ë§Œ ë‚¨ê¸°ê³  ë‚˜ë¨¸ì§„ ì§ì ‘ ë‚ ë ¤ì¤˜ì•¼ í•œë‹¤)
struct IsOdd
{
	bool operator()(int n)
	{
		return n % 2 != 0;
	}
};
//vector<int>::iterator it = remove_if(v.begin(), v.end(), IsOdd());
//v.erase(it, v.end());  // eraseë¥¼ ê¹Œë¨¹ìœ¼ë©´ ë’¤ì— ë°ì´í„°ê°€ ë‚¨ì•„ ìˆëŠ” í˜„ìƒ ë°œìƒ
v.erase(remove_if(v.begin(), v.end(), IsOdd()), v.end()); // ìœ„ ë‘ ì¤„ê³¼ ë™ì¼
```

***

ğŸ“Œ ì´ ì™¸ì—ë„ ë‹¤ì–‘í•œ ì•Œê³ ë¦¬ì¦˜ ë¬¸ë²•ì€ êµ¬ê¸€ë§ì„ í†µí•´ í•„ìš”í•  ë•Œë§ˆë‹¤ ìµí˜€ë‚˜ê°€ì!
