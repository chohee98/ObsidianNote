## List (노드)
- List는 STL 컨테이너 중 하나로 연결 리스트(Linked List)라고도 불린다 (vector = 동적배열)
- 데이터들이 연속된 공간에 배치되어야 한다는 제약이 없어지고 다음 데이터가 어디 있는지 포인터로 저장되는 특징이 있다 (단일/*이중*/원형 연결리스트)

### List의 동작 원리
```cpp
#include <iostream>
using namespace std;
#include <list>

class Node
{
public:
    // 포인터는 주소값을 담는 바구니 (4 or 8바이트 고정 크기) -> 설계도를 최종적으로 완성 가능
    // 포인터가 아닐 경우 자기 자신을 완성 시켜야 최종 설계도를 완성할 수 있으므로 무한 반복...
    Node* _next; // 다음 노드의 주소값
    Node* _prev; // 이중 연결 리스트나 원형 연결 리스트일 경우 이전 노드의 주소값 추가
    int _data;
};

int main()
{
    list<int> li;

    for (int i = 0; i < 100; i++)
        li.push_back(i);

    li.push_front(10); // 벡터와 달리 push_front 지원 (벡터보다 효율적으로 동작) 🔥
    int size = li.size();
    //li.capacity(); // 없음 (동적 배열이 아니기 때문)

    int first = li.front();
    int last = li.back();

    //li[3] = 10; // 없음 -> 임의 접근(Random Access)가 불가해 동적 배열보다 탐색이 어렵다

    list<int>::iterator itBegin = li.begin(); // iterator는 ptrBegin 노드의 _next를 가리키는 주소 (&_next 밑으로 &_prev, _data 값 저장되어 있음)
    list<int>::iterator itEnd = li.end();

	int* ptrBegin = &(li.front());  // 첫번쨰 데이터가 들어간 주소값
    int* ptrEnd = &(li.back());

    for (list<int>::iterator it = li.begin(); it != li.end(); ++it)
    {
        cout << *it << endl;
    }

    li.insert(itBegin, 100);
    li.erase(li.begin());
    li.pop_front();
    li.remove(10); // 벡터처럼 for문을 돌면서 하나씩 삭제하지 않아도 됨 🔥

    return 0;
}
```


### list 삽입/삭제
- 노드가 저장하고 있는 포인터의 값만 변경해주면 된다는 이점이 있다 (노드 기반)

### 임의 접근
- 데이터들이 저 멀리 분리되어 저장되어 있기 때문에 처음부터 이동하며 찾아 느리다 (임의 접근 연산자가 막혀있다 `li[3]`)