`데이터를 가공하는 방법` `#pragma region 00 / #pragma endregion 을 쓰면 접기 가능`

## 산술연산
- #대입연산: `a = b = 3` a에 b 를 대입하고 b 를 반환하라
- #사칙연산:  +   -   /   %   +=   -=   * =   /=   %=   ++   --- 
    - `b = a++` : b에 대입 후 a 값 증가
    - b = ++a : a 값 증가 후 b에 대입
    - ![[전위증가후위증가.png]]

***

## 비교 연산과 논리 연산
- #비교연산  ==   !=   >   >=   <   <=   (참이면 1 아니면 0)
- #논리연산 조건에 대한 논리적 사고가 필요할 때     !(반전)   &&(and)   ||(or)
- ![[비교연산.png]] 
- ![[논리연산2.png]]
    - test는 and 연산을 의미하며 eax 값이 0인지 아닌지 확인하고 jne에 걸리면 0이 아니었다는 의미가 됨 -> 0이 아니었으면 점프
    - ebp-0C4h는 스텍 프레임 안의 어딘가로 여기에 잠시 0 또는 1을 기입
- ![[논리연산1.png]]

***

## 비트연산 
- #비트연산 : 비트 단위의 조작이 필요할 때 #논리연산 #시프트연산 
- 대표적으로 **BitFlag***
- ~ bitwise not : 단일 숫자의 모든 비트를 대상으로 비트 반전
- & bitwise and : 두 숫자의 모든 비트 쌍을 대상으로 and 진행
- | bitwise or : 두 숫자의 모든 비트 쌍을 대상으로 or 진행
- ^ bitwise xor : 두 숫자의 모든 비트 쌍을 대상으로 xor 진행 (<mark style="background: #0E4F9FA6;">xor: 두 수 가 같으면 1 아니면 0</mark>)
- << 비트 좌측 이동 : 비트열의 n만큼 왼쪽으로 이동 -> 왼쪽의 넘치는 n개의 비트는 버리고 새로 생성되는 n개의 비트는 0으로. (* 2)를 할 때 자주 보이는 패턴
- >> 비트 우측 이동 : 비트열의 n만큼 오른쪽으로 이동 -> <mark style="background: #824CB496;">오른쪽의 넘치는 n개의 비트는 버리고 왼쪽 새로 생성되는 n개의 비트는 부호 비트가 있을 경우 부호 비트를 따라가고 아니면 0</mark>. (/ 2)를 할 때 자주 보이는 패턴
- BitFlag 할 때 숫자를 *unsigned 타입*으로 만들어 주는 게 정신 건강에 좋다, 비트플래그를 사용하면 boolean 노가다를 막을 수 있다

```cpp
unsigned char flag;	// 부호를 없애야 >> 를 하더라도 부호 비트가 딸려오지 않음

int main()
{
#pragma region 비트연산
	// 0b0000 [무적][변이][스턴][공중부양]

	const int INVINCIBLE = 3;
	flag = (1 << INVINCIBLE);	//무적 상태
	flag |= (1 << 2);	        //무적 + 변이

	//bitmask 무적인지 확인하고 싶다
	bool invincible = ((flag & (1 << 3)) != 0);   // true

	// 무적이거나 스턴 상태 인지 확인
	bool mask = (1 << 3) | (1 << 1);
	bool stunOrInvicible = ((flag & mask) != 0);   // true
#pragma endregion
}

```