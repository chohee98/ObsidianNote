> 데이터를 가공하는 방법
## 📌 Tip
`#pragma region 00` / `#pragma endregion` 을 쓰면 해당 영역을 접고 펼 수 있다

***

# 산술연산
- 대입연산: `a = b = 3` -> a에 b 를 대입하고 b 를 반환하라
- 사칙연산:  +   -   /   %   +=   -=   * =   /=   %=   ++   --- 
	- 게임 만들 때 데미지를 계산하거나, 체력을 깎거나, 루프문에서 카운터를 1 증가하거나 등 아주 다양하게 쓰인다.
    - `b = a++` : b에 대입 후 a 값 증가
    - `b = ++a` : a 값 증가 후 b에 대입 
      ![[전위증가후위증가.png]]

***

# 비교 연산과 논리 연산
- 비교연산 :  `==   !=   >   >=   <   <=`   (참이면 1 아니면 0) ![[비교연산.png|330]]
- 논리연산 :  조건에 대한 논리적 사고가 필요할 때     `!(NOT)   &&(AND)   ||(OR)`   ![[논리연산2.png|330]]   ![[논리연산1.png|330]]
    - ex) !not 어셈블리어 분석
    1. test는 and 연산을 의미하며 eax 값이 0인지 아닌지 확인하고 jne에 걸리면 0이 아니었다는 의미가 됨 -> 0이 아니었으면 6B로 점프
    2. ebp-0C4h는 잠시 메모장처럼 스텍 프레임 안의 어딘가로 여기에 잠시 0 또는 1을 기입
    3. 최종적으로 결과가 나왔으면 그것을 cl 레지스터에 옮겨주고 그 값을 test 바구니 안에 넣기 

***

# 비트연산
- 비트 단위의 조작이 필요할 때 주로 사용된다. 대표적으로 **BitFlag**가 존재
- `^(bit or)`, `>>(오른쪽 시프트)`, `<<(왼쪽 시프트)` 주의해서 보기
- BitFlag 할 때 숫자를 *unsigned 타입*으로 만들어 줘야 오른쪽 시프트를 했을 때 부호 비트가 딸려오지 않는다
```cpp
// ~ : bitwise not
// 단일 숫자의 모든 비트를 대상으로 반전
0101 1000 --> 1010 0111

// & : bitwise and
// 두 숫자의 모든 비트 쌍을 대상으로 AND
0101 1000
1001 0110
---------
0001 0000

// | : bitwise or
// 두 숫자의 모든 비트 쌍을 대상으로 OR
0101 1000
1001 0110
---------
1101 1110

// ^ : bitwise xor 🏹
// 두 숫자의 모든 비트 쌍을 대상으로 XOR !!!!!!!
// 두 수가 같으면 0, 다르면 1 출력 (둘이 같은거 시러함)
0101 1000
0101 1000
---------
0000 0000   // 같은 비트끼리 XOR을 진행하면 0이 나오기 때문에 비교할 때 유리

// 같은 xor 연산을 두 번하면 기존의 값이 반환된다는 특성 -> 암호학적으로 주로 사용된다
0101 1000   // xa
1001 0110   // xb
---------
1100 1110   // xa' = xa ^ xb

1100 1110   // xa'
1001 0110   // xb
---------
0101 1000   // xa = xa' ^ xb : 초기 xa 값이 그대로 나옴

// << : 왼쪽 시프트(비트 좌측 이동) 🏹
// 왼쪽에 넘치는 n개의 비트는 사라지고 오른쪽에 새로 생기는 n개의 비트는 0으로 채워진다
// *2를 할 때 자주 보이는 패턴 (이진수라서)
0101 1000 << 1 --> 1011 0000

// >> : 오른쪽 시프트(비트 우측 이동) 🏹
// 왼쪽에 새로 생기는 n개의 비트는 0으로 채워지고 오른쪽에 넘치는 n개의 비트는 버린다
// 단, 부호 비트가 존재할 경우(음수일 경우), 부호 비트를 따라간다 !!!!!
0101 1000 >> 1 --> 0010 1100
1101 1000 >> 1 --> 1110 1100
```

```cpp
// 비트 플래그
// bool 형으로 여러 변수를 만드는 것보다 비트 플래그를 이용하여 0 1로 특별한 의미 부여
unsigned char flag;	// 부호를 없애야 >> 를 하더라도 부호 비트가 딸려오지 않음

int main()
{
#pragma region 비트연산
	// 0b0000 [무적][변이][스턴][공중부양]
	/*
	flag = 8;  //1000
	위처럼 비트에 해당하는 값을 직접 넣어도 되지만 4bit 가 아니라 64bit 일 경우 어마어마하게
	큰 수를 직접 넣는건 무리... 그래서 시프트 연산을 통해 아래처럼 조립해서 넣어주기
	flag = (1 << 3);
	윗 줄을 디스어셈블리로 살펴보면 (1 << 3) 은 8이라는 숫자를 바로 대입하기 때문에 처음처럼 
	직접 8을 넣는 것과 성능적으로 차이가 없다. 그러 가독성을 위해 (1 << 3)을 사용
	*/

	const int INVINCIBLE = 3;
	flag = (1 << INVINCIBLE);	// 무적 상태 flag=8 (0b1000)
	flag |= (1 << 2);	        // 변이 상태 추가 (무적 + 변이) flag-12 (0b1100)

	//bitmask(필요 없는 정보는 날릴 수 있다) 무적인지 확인하고 싶다
	// 원하는 부분만 1로 두기 때문에 나머지 자리는 0과 and연산을 하니까 0이 되어 날아간다
	bool invincible = ((flag & (1 << 3)) != 0);   // true

	// 무적이거나 스턴 상태 인지 확인
	bool mask = (1 << 3) | (1 << 1);
	bool stunOrInvicible = ((flag & mask) != 0);   // true
#pragma endregion
}
```