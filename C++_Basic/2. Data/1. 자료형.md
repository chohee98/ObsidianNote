`.sln 은 솔루션 파일`  `디버깅 모드를 시작하고 ctrl+alt+d 키를 통해 어셈블리어 확인 가능`
`ctrl+k + c/u 키를 통해 단체 주석(Comment)/해제(UnComment)`

## 정수
- #정수 자연수, 0, 음수
- C++에서도 어셈블리어와 똑같이 변수의 초기화 값이 있으면 *.data영역*으로, 초기 값이 0이거나 초기 값이 없는 변수면 *.bss영역*으로 가게 됨 
- char = 1바이트 (-128~127),  short = 2바이트 (-32768~32767),   int = 4바이트(-21.4억~21.4억),  __ int64 = 8바이트 
- 평소에 자료형 변수 앞에는 부호를 나타내는 (최상위 비트) signed가 생략되어 있음 (unsigned는 무조건 양수로 보겠다는 의미 최상위 비트 필요x)
- unsigned char = 1바이트 (0~255),  unsigned short = 2바이트 (0~65536),   unsigned int = 4바이트 (0~42.9억),  unsigned __ int64 = 8바이트
- 콘솔이나 모바일 게임을 제작할 경우 항상 메모리가 부족하기 때문에 자료형을 하나로 통일하면 메모리 손해를 볼 수 있다
- 음수가 필요 없는 레벨 같은 경우 insigned로 먄드냐 signed로 만드냐는 팀 성향에 따라 차이가 날 수 있음
- 정수 #오버플로우 가 발생하면 숫자가 확 바뀔 수 있으니 주의! (ex) `short b = 32767; b+=1`을 했을 때 b 값은 -32768이 됨)

***

## 불리언( boolean): 참/거짓
- #bool = 1바이트 정수
- bool만 봐도 참/거짓 둘 중 하나라는 힌트를 줘서 "가독성"이 좋음
- 참 거짓만 표현할 거면 1비트면 쓰면 되지 구지 1바이트를 쓰는 이유는 그냥 최소 단위가 1바이트 이기 때문...

***

## 실수 (부동소수점)
- #실수 float = 4바이트,  double = 8바이트
- `float attackSpeed = 0.639f` `double sttackSpeed2 = 123.4123` float형의 경우 실수 뒤에 f 붙여주기
- 컴퓨터가 실수를 표현하는 방법 "**부동소수점**" => .을 유동적으로 움직여서 표현하는 방법
- ex) 3.1415926535
    1. 정규화 = 0.31415926535 * 10
    2. 314159265 (유효 숫자), 1 (지수)
- float : 부호(1), 지수(8), 유효숫자(23) = 32비트 = 4바이트
- double: 부호(1), 지수(11), 유효숫자(52) = 64비트 = 8바이트
- 프로그래밍 할 때 부동소수점은 항상 '==근사값==' 이므로 수가 커질 수록 오차 범위도 커짐
- 실수 2개를 == 으로 비교하는 것은 지양

```cpp
#include <iostream>
using namespace std;

float attackSpeed = -3.375f;

// ex) -3.375라는 값을 저장
// 1) 2진수 변환 = (3) + (0.375) = 0b11 + 0b0.011 = 0b11.011
// 0.375 = 2^(-1)*0 + 2^(-2)*1 + 2^(-3)*1 = 0.5 * 0 + 0.25 * 1 + 0.125 * 1 = 0b0.011
// 2) 정규화 0b1.1011 * 2^1
// 1(부호) 1(지수) 1011(유효숫자)
// 단 지수는 unsigned byte 라고 가정하고 숫자+127 만들어줌
// 예상 결과 : 0b 1 10000000 1011000'0000'0000'0000'0000 [부호(1), 지수(8), 유효숫자(23)]

int main()
{
    cout << "Hello World!" << endl;
}
```
![[float.png]]

***

## 문자와 문자열
- #문자 char: 알파벳이나 숫자 문자를 나타냄,  wchar_t: 유니코드 문자를 나타냄
- "문자는 숫자인데 여기에 어떤 특별한 의미를 부여해서 아스키코드나 다른 변환 방법을 이용해서 문자를 표현하는 방법이다."
- `char ch = 97` 을 하면 "아스키 코드" 로 해당 숫자에 해당하는 문자 출력
- `char ch = 'a'` 위와 동일한 결과
- `char ch = 'a' + 1` 과 같이 표현해서 b를 출력할 수도 있음
- 전 세계 모든 문자에 대해 유일 코드를 부여한 것이 **유니코드 (unicode)**
- 유니코드는 표기 방식이 여러가지가 있는데 대표적으로 UTF8 UTF16
- UTF8: 알파벳, 숫자 1바이트, 유럽 지역의 문자는 2바이트, 한글과 한자 등은 3바이트
- UTF16: 알파벳 숫자 한글 한자 등 거의 대부분 문자 2바이트, 매우 예외적인 고대 문자만 4바이트 `wchar_t wch = L'초'`
```cpp
wchar_t wch = L'초';

int main()
{
    wcout.imbue(locale("kor"));
    wcout << wch << endl;
}
```
- #EscapeSequence : 표기하기 어려운 애들 표현 \r = CarriageReturn (커서 <<)
- #문자열 문자들이 열을 지어서 모여 있는 것 -> 문자 배열 
- `char str[] = { 'h', 'e', 'l', 'l', 'o'}` 을 main문 밖의 데이터 영역에 넣으면 데이터가 이미 0으로 초기화 되어 문제가 없지만 main문 안에 넣으면 뒤에 쓰레기 값이 붙기 때문에 `char str[] = { 'h', 'e', 'l', 'l', 'o', '\0'}` 뒤에 null을 붙여줘야 한다.
- `char str[] = "hello world"` `wchar_t str[] = L"hello world"` 처럼 깔끔하게도 표현 가능 (뒤에 null 값은 자동으로 따라 붙음)