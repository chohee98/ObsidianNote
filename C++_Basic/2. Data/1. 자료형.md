## 📌 Tip
디버깅 모드를 시작하고  (디버그>창>디스어셈블리) or `Ctrl+Alt+D` 단축키를 통해 **Assembly 언어 확인** 가능
디버깅 모드를 시작하고  (디버그>창>메모리>메모리 1) or `Ctrl+Alt+M` 단축키를 통해 **메모리 창**
Ctrl+K + C/U 키를 통해 단체 **주석**(Comment)/해제(UnComment)

> Assembly 언어는 컴퓨터 관점에서 보는 세상으로 Assembly 언어 한 줄이 사실상 CPU Instruction 한 개랑 거의 1:1 대칭

***

# 정수
- 어셈블리어와 똑같이 변수의 초기화 값이 있으면 *.data영역*으로, 초기 값이 0이거나 초기 값이 없는 변수면 *.bss영역*으로 가게 된다 (C++에선 영역을 정해주지 않아도 컴파일러가 알아서 변수를 옮겨주기 때문에 따로 공간 지정할 필요가 없다)
- 평소에 자료형 변수 앞에는 부호를 나타내는 (최상위 비트) signed가 생략되어 있다 (unsigned는 무조건 양수로 보겠다는 의미 최상위 비트 필요x)
- 콘솔/모바일 게임을 제작할 경우 항상 메모리가 부족하기 때문에 어느 정도 범위 예측이 된다면 그에 맞는 타입을 사용하는 게 메모리 관리에 좋다
	- 참고) 이론적으로 양수만 존재할 수 있는 데이터라면 무조건 unsigned를 사용?
	- 레벨이 음수라는 것은 말이 안 된다 -> 차라리 그 자리에서 프로그램을 크래시 내서 버그를 빨리 찾는 게 낫다
	- unsigned / signed 사이의 변환에서 버그가 일어날 수 있다
	- 고로 이건 팀 분위기, 코딩 스타일 에 따라서 다르다!
- <mark style="background: #824CB496;">정수 오버플로우</mark>가 발생하면 숫자가 확 바뀔 수 있으니 주의! (ex) `short b = 32767; b+=1;`을 했을 때 b 값은 `-32768`이 된다)
```c++
char a;  // 1바이트 (-128~127)
short b; // 2바이트 (-32768~32767)
int c; // 4바이트 (-21.4억~21.4억)
__int64 d; // 8바이트(long long) (어마어마하게 큼)
```

```c++
unsigned char a; // 1바이트 (0~255)
unsigned short b; // 2바이트 (0~65536)
unsigned int c; // 4바이트 (0~42.9억)
unsigned __int64 d; // 8바이트(long long) (0~어마어마하게 큼)
```

***

# 불리언( Boolean): 참/거짓
- 1바이트 정수로 참은 1, 거짓은 0으로 저장
- Assembly 에서 bool이라는 것은 없다 -> 0 이나 1 값을 이용해서 참 거짓 판단
- 하지만 C++에선 bool만 봐도 참/거짓 둘 중 하나라는 힌트를 줘서 "가독성"이 좋게 한다
- 참 거짓만 표현할 거면 1비트면 쓰면 되지 구지 1바이트를 쓰는 이유는 <mark style="background: #0E4F9FA6;">그냥 최소 단위가 1바이트 이기 때문</mark>...

***

# 실수 (부동소수점)
- 소수를 포함한 숫자 -> `float` = 4바이트,  `double` = 8바이트
- `float attackSpeed = 0.639f` `double sttackSpeed2 = 123.4123` float형의 경우 실수 뒤에 f 붙여주기
- 컴퓨터가 실수를 표현하는 방법 "**부동(浮動)소수점**"  👉  `.` 을 유동적으로 움직여서 표현
	- float : 부호(1), 지수(8), 유효숫자(23) = 32비트 = 4바이트
	- double: 부호(1), 지수(11), 유효숫자(52) = 64비트 = 8바이트
- 프로그래밍 할 때 <mark style="background: #824CB496;">부동소수점은 항상 '근사값'</mark> 이므로 수가 커질 수록 오차 범위도 커진다 -> 실수 2개를 == 으로 비교하는 것은 지양!!

```cpp
#include <iostream>
using namespace std;

//ex) 3.1415926535 (실수를 비트화 시키기)
//    1. 정규화 = 0.31415926535 * 10
//    2. 314159265 (유효 숫자), 1 (지수)

float attackSpeed = -3.375f;

// ex) -3.375라는 값을 저장
// 1) 2진수 변환 = (3) + (0.375) = 0b11 + 0b0.011 = 0b11.011
// 0.375 = 2^(-1)*0 + 2^(-2)*1 + 2^(-3)*1 = 0.5 * 0 + 0.25 * 1 + 0.125 * 1 = 0b0.011
// 2) 정규화 0b1.1011 * 2^1
// 1(부호) 1(지수) 1011(유효숫자)
// 단 지수는 unsigned byte 라고 가정하고 숫자+127 만들어줌
// 예상 결과 : 0b 1 10000000 1011000'0000'0000'0000'0000 [부호(1), 지수(8), 유효숫자(23)]
// 메모리에서 확인 시 리틀 앤디안으로 저장이 되어있기 때문에 뒤집어줘야 함

int main()
{
    cout << "Hello World!" << endl;
}
```
![[부동소수점.png]]

***

# 문자와 문자열
### 문자
- char: 알파벳이나 숫자 문자,  wchar_t: 유니코드 문자를 나타낸다
- "문자는 숫자인데 여기에 어떤 특별한 의미를 부여해서 아스키코드나 다른 변환 방법을 이용해서 문자를 표현하는 방법이다"
- 영어 뿐 아니라 전 세계 모든 문자에 대해 유일 코드를 부여한 것이 **유니코드 (unicode)**
	- 유니코드는 표기 방식이 여러가지가 있는데 대표적으로 UTF8 UTF16
	- UTF8: 알파벳&숫자 1바이트, 유럽 지역의 문자는 2바이트, 한글과 한자 등은 3바이트
	- UTF16: 알파벳&숫자&한글&한자 등 거의 대부분 문자 2바이트, 매우 예외적인 고대 문자만 4바이트 `wchar_t wch = L'초'`
	- 알파벳과 숫자만 사용할거면 용량이 적은 UTF8을 사용해도 되지만, 한글을 사용할 경우 UTF8은 3바이트로 크기가 커지게 되지만 UTF16은 2바이트로 고정되어 길이 예측이 쉬워 용량 관리에 편하다는 점이 있다
```cpp
char ch = 97;      // "아스키 코드" 로 해당 숫자에 해당하는 문자 출력
char ch = 'a'      // 위와 동일한 결과
char ch = 'a' + 1  // 이와 같이 표현해서 b를 출력할 수도 있음

wchar_t wch = L'초';

int main()
{
    wcout.imbue(locale("kor")); // 한국어 인식 시켜기기
    wcout << wch << endl        // cout은 char 전용이기 때문에 wcout 사용
}
```

```cpp
// EscapeSequence: 표기하기 애매한 문자 표현
// \t = 아스키코드 9 = Tab
// \n = 아스키코드 10 = LineFeed(한 줄 아래로)
// \r = 아스키코드 13 = CarriageReturn(커서 «)
```


### 문자열
- 문자들이 열을 지어서 모여 있는 것 -> 문자 배열 
- `char str[] = { 'h', 'e', 'l', 'l', 'o'}` 을 <mark style="background: #824CB496;">main문 밖(.data)에 넣으면 데이터가 이미 0으로 초기화 되어 문제가 없지만, 스택 메모리에 저장하기 위해 main문 안에 넣으면 문자열 뒤에 쓰레기 값이 붙기 때문에 null을 붙여줘야 한다</mark> -> `char str[] = { 'h', 'e', 'l', 'l', 'o', '\0'}
```cpp
// 문자열: 문자들이 열을 지어서 모여 있는 것 -> 문자 배열 
// .daa영역에선 뒤에 null 값이 자동으로 따라 붙음
char str[] = { 'h', 'e', 'l', 'l', 'o'};
char str2[] = "hello world";        // 문자열의 길이는 12 (마지막에 0 값)
wchar_t str[] = L"hello world;

int main()
{
	str[] = { 'h', 'e', 'l', 'l', 'o', '\0'};
}
```