> C++은 메모리 공간에 직접 할당할 수 있기 때문에 우리가 하는 모든 행동에 책임을 져야 한다.

# Const(상수)
- 한 번 정해지면 절대 바뀌지 않는 값으로 constant의 약자인 const 를 사용 (변수를 상수화)
- **const 를 붙였으면 초기 값을 반드시 지정**해야 한다
- '바뀌지 않는 값은 대문자로 변수 이름 지정'
```cpp
unsigned char flag;

const int AIR = 0;
const int STUN = 1;
const int POLYMORPH = 2;
const int INVINCIBLE = 3;

// 전역변수 [데이터 영역]
// .data (초기값 있는 경우)
int a = 2;
// .bss (초기값 없는 경우)
int b;
// .rodata (읽기 전용 데이터)
const char* msg = "Hello World";

// 함수: 어셈블리에서 보던 프로시저(비슷한 기능을 묶어서 편하게 호출할 수 있게 만든 것)의 개념
int main()
{
	// 지역변수 [스택 영역]
	int c = 3;
	
	// 0b0000 [무적][변이][스턴][공중부양]
	flag = (1 << INVINCIBLE);	//무적 상태
	flag |= (1 << POLYMORPH);	//무적 + 변이
	//bitmask 무적인지 확인하고 싶다
	bool invincible = ((flag & (1 << INVINCIBLE)) != 0);
	// 무적이거나 스턴 상태 인지 확인
	bool mask = (1 << INVINCIBLE) | (1 << POLYMORPH);
	bool stunOrInvicible = ((flag & mask) != 0);
}
```

***

# 데이터 영역
- 특정 프로그램이 빌드가 완료되면 실행 파일로 만들어진 다음에 이 실행 파일을 실행하여 메모리에 올라 가고 메모리에 올라가는 순간 stack, heap, data, text 등의 공간이 할당된다  ![[데이터 영역.png|600]]
	- **전역 변수**가 올라가는 data 영역은 .bss 영역, 일반 .data 영역, read-only 데이터 영역 세 가지로 나뉜다
		- `.data`: 초기값이 있는 경우 변수가 저장되는 곳
		- `.bss`: 초기값이 없는 경우 변수가 저장되는 곳
		- `.rodata`: 읽기 전용 데이터 저장, const 포인터 변수가 이 곳에 저장된다
	- **지역 변수**는 스택에 저장된다![[지역변수스택영역.png]]
		- 스택이라는 메모리 자체가 함수와 깊은 연관이 있다 -> 함수에서 인자를 넘기기 위해서 가장 먼저 사용되고, 내부적으로 돌아갈 코드 장소도 따로 저장이 되어 있다!
		- 마지막으로 사용되는 용도가 함수에서 자기기 관리하고 있는 공간 즉, 스택 프레임의 ... 공간에 함수 내부에서 임시적으로 보관하고 싶은 값(지역 변수)을 저장하여 잠시 메모장처럼 사용한다
		- 스택은 사용이 끝났으면 원래 상태로 돌아가 유효하지 않게 된다 (파란 부분 제거)
		- 스택과 관련된 주소는 EBP, ESP 레지스터에서 확인할 수 있다
	
	- <mark style="background: #824CB496;">const가 데이터 영역에 있을 때 셋(.data .bss .rodata) 중에 어디에 저장될지는 그냥 컴파일러 마음이지만, 스택 영역에 있을 때는 스택 영역에 만들어진다!!</mark> 🔥

***

## 유의 사항..
1. 변수의 유효 범위
    - `{ }` 내에 선언된 변수는 스택에 올라가기 때문에, 스택 안에 같은 이름으로 변수를 만들 때 중괄로 변수 사용 범위를 감싸주면 해결된다
	-  전역변수와 지역변수 이름이 겹치지 않게 조심 겹치면 지역변수가 이긴다
2. 연산 우선순위
    - 혼돈의 여지가 있는 경우 (괄호)로 묶으면 가독성을 높일 수 있다
3. 타입 변환
    - 변수 타입이 작아질 경우 위쪽 비트 데이터가 잘린 상태로 저장되어 데이터가 분실 된다
    - 정수에서 실수 변환할 경우 정밀도 차이가 있기 때문에 데이터 손실이 있을 수 있다
    - signed 를 unsigned 로 바꿀 경우 비트 단위로 보면 똑같은데 최상위 비트를 분석하는 방법이 달려져서 차이 발생한다
4. 사칙 연산 관련
    - '곱셈' 의 경우, 너무 큰 수를 곱해서 자료형이 표현할 수 있는 숫자 범위를 넘어서는 오버플로우(overflow) 조심하기 (결과 깨짐) 
    -  '나눗셈' 의 경우, <mark style="background: #FFAB45CF;">0으로 나누지 않는지 조심</mark>하고 `float ratio2 = hp / (float)maxHp;` 와 같이 정수끼리 나눈 값은 정수로 나오기 때문에 둘 중 하나는 강제로 실수 타입으로 변환 후 나눠줘야 한다
5. 기타?
	- C++에서는 변수의 선언 위치에 제한을 두지 않는다
	- 출력에서와 마찬가지로 입력에서도 별도의 서식 지정이 불필요하다