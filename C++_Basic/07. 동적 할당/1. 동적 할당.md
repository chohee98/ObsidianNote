## 메모리 구조
- 코드 영역: 실행할 코드가 저장되는 영역
- 데이터 영역: 전역(global)/정적(static) 변수가 저장되고 프로그램 시작과 동시에 들어갈 내용 결정, 프로그램 종료 시 내려온다
- 스택 영역: 지역 변수/매개 변수가 저장되고 실행 과정에서 메모리 **자동** 할당/소멸된다 #암기
- 힙 영역:  동적 할당? #암기
	- 실제 상황에서 '스택'은 어마어마하게 많은 데이터를 저장하는 용도로 만들어진 것이 아니라 '함수들끼리 인자를 좀 더 자연스럽게 전달하는 용도'로 만들어졌다
	- 그래서 스택 영역의 데이터가 많아지면 스택 오버플로우가 일어난다...
	- 스택 영역은 함수가 함수가 끝나면 같이 정리되는 불안정한 메모리로 잠시 함수에 매개변수를 넘기는 용도로는 좋지만 프로그램 실행하는 동안 계속 데이터를 들고 있을 수 없기 때문에 다량의 몬스터 생성에는 부적합하다
	- 그럼 <mark style="background: #824CB496;">유동성 있게 필요한 만큼만 메모리를 쓰고 필요 없어지면 반환할 수 있는 메모리</mark> 필요! 즉, (스택과는 다르게) 우리가 <mark style="background: #824CB496;">생성/소멸 시점을 관리</mark>할 수 있는 메모리 필요!!
	- 그게 바로 **힙 영역** (**수동** 할당 및 소멸) 이다!!
```cpp
int main()
{
	// 유저 영역 [메모장]  [LOL]  [플레이어] 일반적 프로그램(독립적)
	// -------------------------------------------------------
	// 커널 영역 (Windows 등의 핵심 코드가 돌아가고 있는 상태)

	// LOL에서 새로운 미니언이 탄생해서 메모리 할당해서 만들어줘야 할 때
	// 자기가 멋대로 메모리 조작시 롤에 의해 다른 메모장 등의 애들까지 건들이면 큰일
	// 그래서 유저 영역에서 실행되는 프로그램은 서로 완전히 독립적
	// 그리고 메모리는 롤이 직접 관리하는 개념이 아니라 커널 영역에 요청 후 허락 필요하다

	// 메모리를 요청할 때 메모리를 큼지막하게 받아두고 이걸 쪼개서 사용
	// 힙 영역도 딱 한 개만 받는게 아니라 여러 개를 받아서 잘라서 쓰는 개념
	// C++에서는 기본적으로 CRT(c런타임 라이브러리)의 [힙 관리자]를 통해 힙 영역 사용하지만
	// 정말 원한다면 직접 API를 통해 힙을 생성하고 관리할 수 있다 (MMORPG 서버 메모리 풀링)
	
	Knight knight;   // 스택에 만들기
	Knight* k2 = new Knight();   // 힙에 만들기

	return 0;
}
```


***


## 동적 할당과 연관된 함수/연산자
- `malloc/free, new/delete, new[]/delete[]`
- malloc /  free
	- **malloc**은 인자로 할당 받을 **메모리 크기**를 받고 메모리 할당 후 시작 주소를 가리키는 void 포인터를 반환해준다 (메모리 부족 시  `nullptr` 반환)
	- 잠깐!! `void*`는 포인터를 타고 가면 void 즉 뭐가 있는지 모르겠으니까 (어떻게 사용할지 지정을 해주는 상태가 아니니까) 너가 적당히 변환해서 사용하라는 느낌이다 #void포인터
	- **free**는 malloc을 통해 할당된 영역을 해제  ➡️  힙 관리자가 할당/미할당 여부를 구분해서 관리한다
		- 메모리를 해제 할 때는 malloc처럼 sizeof로 사이즈 정보를 전달해 주지 않아도 된다
		- 힙 관리자에게 메모리 요청을 하면 <mark style="background: #0E4F9FA6;">몇 바이트를 사용했는지 정보도 "헤더"에 넣어서 같이 전해준다</mark>
		- 그래서 free 를 할 때 몇 바이트인지 입력을 하지 않아도 찾아서 메모리를 날릴 수 있다
- 버그 발생 상황!
	- *Heap Overflow*: 유효한 힙 범위를 초과해서 사용하는 문제로 프로그램의 안정성과 보안에 영향을 미친다
	- *메모리누수*: 사용이 끝난 메모리를 해제(free)를 해주지 않아 메모리가 낭비되는 현상으로 성능 문제를 유발한다
	- *Double Free*: 메모리 할당 해제(free)를 여러 번 하는 문제로 대부분 두 번째 할당 해제 시에 이미 유효하지 않은 값이 들어있는 걸 체크했기 때문에 크래시만 나고 끝난다
	- *Use-After-Free*: `void* pointer = malloc(sizeof(Monster))` <mark style="background: #824CB496;">메모리를 할당 해제한 후에도</mark> 포인터 자체가 없어진 게 아니기 때문에 <mark style="background: #824CB496;">포인터 변수를 통헤 이 주소에 다시 접근 가능</mark>하다. 엉뚱한 메모리를 계속 건드릴 수 있음 `pointer = nullptr;` 을 통해 예방할 수 있다  ➡️  바로 크래시가 나지 않고 다른 부분을 건드리게 되기 때문에 가장 위험한 에러니 조심하자!!
```cpp
class Monster
{
public:
	int _hp;
	int _x;
	int _y;
};


int main()
{
	// typedef a b; 는 a라는 타입한테 b라는 이름으로도 사용하게끔 만들어준다는 의미
	// malloc(size_t)에서 size_t는 typedef unsigned int size_t; 
	void* pointer = malloc(sizeof(Monster));
	
	Monster* m1 = (Monster*)pointer;
	m1->_hp = 100;
	m1->_x = 1;
	m1->_y = 2;

	free(pointer);
	pointer = nullptr;

	return 0;
}
```
- new / delete
	- **malloc/free는 함수! new/delete는 연산자(operator)**
	- `new/delete`는 `malloc/free`와 다르게 할당받을 메모리의 크기를 직접적으로 설정할 수 없는 점을 보완하기 위해 배열이 추가된 문법이 존재한다
		- `new[] / delete[]` 는 new가 malloc에 비해 좋긴 한데 배열과 같이 n개 데이터를 같이 할당하기 위해 사용한다
		- `new[]` 는 `delete[]`로 생성된 만큼 날려주기 (짝 맞추기)
```cpp
class Monster
{
public:
	Monster()
	{
		cout << "Monster()" << endl;
	}
	~Monster()
	{
		cout << "~Monster()" << endl;
	}

public:
	int _hp;
	int _x;
	int _y;
};


int main()
{
	Monster* m2 = new Monster; 
	Monster& ref = *m2;  // 참조자를 이용한 힙 접근 가능!!
	ref._hp = 100;
	
	m2->_hp = 200;
	m2->_x = 2;
	m2->_y = 3;
	delete m2;

	Monster* m3 = new Monster[5]; // 여러 마리를 동시에 만들어주는 문법 (m3의 크기는 12*5)
	m3->_hp = 200;
	m3->_x = 2;
	m3->_y = 3;

	Monster* m4 = (m3 + 1);
	m4->_hp = 500;
	m4->_x = 5;
	m4->_y = 10;

	delete[] m3;  // m3를 할당 해제하면 m4의 값들도 모두 사라진다

	return 0;
}
```

### 둘의 가장 근본적인 차이는?
- 편의성 측면은 `new/delete` 가 유리하지만 타입에 상관 없이 특정한 크기의 메모리 영역을 할당 받으려면? `malloc/free` 가 승리
- <mark style="background: #FFAB45CF;">new/delete는 (생성 타입이 클래스 일 경우) 생성자/소멸자를 호출해준다</mark> #암기
- malloc에서 `Monster* m1 = (Monster*)pointer;`는 우리가 강제로 몬스터라고 간주해서 pointer를 사용하겠다는 거지 몬스터를 만들었다는 내용은 어디에도 없기 때문에 몬스터의 생성자는 호출되지 않는다 (메모리만 할당할게 느낌, 객체와 연관 지어서 생성자를 호출하는 개념은 아님)
- new에서 `Monster* m2 = new Monster`는 몬스터 생성자가 애를 만들어준 동시에 몬스터 생성자가 간접적으로 호출한다