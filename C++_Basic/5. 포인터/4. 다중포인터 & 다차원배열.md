## 다중 포인터
- 포인터는 주소를 이용하여 원본에 접근할 수 있다는 장점이 있음
- `msg` 에 담겨있는 값은 "Hello *주소*"
- `*` 을 하나씩 까면서 타고 간다고 생각하기
```cpp
void SetMessage(const char* a)
{
	a = "Bye";  // a = Bye의 주소
}

void SetMessage1(const char** a) // 이중 포인터
{
	*a = "Bye";  //msg = Bye의 주소
}

void SetMessage2(const char*& a) // & = 참조
{
	a = "Wow"; // msg = Bye의 주소
}

int main()
{
	// .rdata Hello주소[H][e][l][l][o][\0]
	// .rdata Bye주소[B][y][e][\0]
	// msg[  Hello 주소  ] << 8바이트
	const char* msg = "Hello";
	SetMessage(msg);   // Hello에 아무 영향도 끼치지 못함. Hello

	// .rdata Hello주소[H][e][l][l][o][\0] << 1바이트
	// msg[  Hello 주소  ] << 8바이트
	// pp[  &msg  ] << 8바이트
	const char** pp = &msg;
	SetMessage1(&msg);  // Bye

	SetMessage2(msg);
	cout << msg << endl;  // Wow
}
```

***

## 다차원 배열
- 2차원 배열도 1차원 배열에서처럼  <mark style="background: #824CB496;">연이어</mark> 메모리에 올라가 있음 (1차원과 메모리 구조 동일)
- 어셈블리어에서 배열의 0번 데이터에서 1번 데이터로 이동할 땐 1만큼 이동하는게 아니라 `mov eax, apartment2D[ecx+edx*4]` 데이터 크기만큼 증가
- 2차 배열은 언제 사용할까? 대표적으로 2D 로그라이크 맵 (해당 지역에 갈 수 있는지 없는 지를 0, 1 로 체크)
```cpp
int main()
{
	int apartment2D[2][5] = { {4, 2, 3, 4, 1}, {1, 2, 5, 2, 2} };
	for(int floor = 0; floor < 2; floor++)
	{
		for(int room = 0; room < 5; room++)
		{
			// apartment2D + (floor * 20) + room * 4를 한 주소
			int num = apartment2D[floor][room];
			cout << num << " ";
		}
		cout << endl;
	}
	return 0;
}
```

***

## 마무리
### 2차원 배열 vs 다중 포인터
- 2차원 배열을 멋대로 다중 포인터로 변환하는 것은 위험
```cpp
int main()
{
	int* p;	// p는 단지 그 곳으로 워프하는 포탈
	int arr[10] = { 1,2,3,4,5,6,7,8 };	// 큰 데이터 묶음

	 // 그런데 많은 사람들이 [배열 = 포인터]라고 착각
	// - [배열 이름]은 배열의 시작 주소값을 가리키는 TYPE* 포인터로 변환 가능
	p = arr;
	// - [TYPE형 1차원 배열]과 [TYPE*형 포인터]는 완전히 호환
	cout << p[0] << endl;
	cout << arr[0] << endl;
	cout << *p << endl;
	cout << *arr << endl;


	// 2차원 배열 vs 다중 포인터
	int arr2[2][2] = { {1,2}, {3, 4} };

	// 주소2[ ] << 4바이트
	// 주소1[ 주소2가 아니라 00000001이 있음 ]
	// pp[ 주소1(arr2) ]
	// 주소가 있어야 할 곳에 숫자가 들어있어 타입이 맞지 않아 크래시를 일으킴
	// 2차원 배열과 다중 포인터는 서로 호환되지 않는 타입이다
	//int** pp = (int**)arr2; 
	// cout << (**pp) << endl;

	// int()[2] 주소를 타고 가면 int가 2개짜리인 배열이 있음 [1][2]
	// [ 주소 ]
	int(*p2)[2] = arr2;
	cout << (*p2)[0] << endl;	// 1 = p2[0][0]
	cout << (*(p2 + 1))[0] << endl;	// 3 = p2[1][0]

	return 0;
}
```


