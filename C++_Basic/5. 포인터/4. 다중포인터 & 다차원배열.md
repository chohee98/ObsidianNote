## 다중 포인터
- 포인터는 주소를 이용하여 원본에 접근할 수 있다는 장점이 있음
```cpp
void SetMessage(const char** a)
{
	*a = "Bye";
}

void SetMessage2(const char*& a)
{
	a = "Wow";
}

int main()
{
	const char* msg = "Hello";

	// .rdata Hello주소[H][e][l][l][o][\0] << 1바이트
	// msg[  Hello 주소  ] << 8바이트
	// pp[  &msg  ] << 8바이트
	const char** pp = &msg;
	SetMessage(&msg);
	*pp = "Bye";

	SetMessage2(msg);
}
```

***

## 다차원 배열
- 2차원 배열도 1차원 배열에서 처럼 같은 배열 타입끼리 <mark style="background: #FF898996;">연이어</mark> 등장 (1차원처럼 쭉 나열)
- 어셈블리어에서 배열의 0번 데이터에서 1번 데이터로 이동할 땐 1만큼 이동하는게 아니라 `mov eax, apartment2D[ecx+edx*4]` 데이터 크기만큼 증가
- 2차 배열은 언제 사용할까? 대표적으로 2D 로그라이크 맵
```cpp
int main()
{
	int apartment2D[2][5] = { {4, 2, 3, 4, 1}, {1, 2, 5, 2, 2} }
	for(int floor = 0; floor < 2; floor++)
	{
		for(int room = 0; room < 5; room++)
		{
			// apartment2D + (floor * 20) + room * 4를 한 주소
			int num = apartment2D[floor][room];
			cout << num << " ";
		}
		cout << endl;
	}
	return 0;
}
```

***

## 2차원 배열 vs 다중 포인터
```cpp
int main()
{
	int arr2[2][2] = { {1,2}, {3, 4} };

	// 주소2[ ] << 4바이트
	// 주소1[ 00000001 ]
	// pp[ 주소1 ]
	// 주소가 있어야 할 곳에 숫자가 들어있어 타입이 맞지 않아 크래시를 일으킴
	// 2차원 배열과 다중 포인터는 서로 호환되지 않는 타입이다
	//int** pp = (int**)arr2; 
	
	// [1][2] [3][4]
	// [ 주소 ]
	int(*p2)[2] = arr2;
	cout << (*p2)[0] << endl;	// 1
	cout << (*(p2 + 1))[0] << endl;	// 3

	cout << p2[0][0] << endl;
	cout << p2[1][0] << endl;

	return 0;
}
```

