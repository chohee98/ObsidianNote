## 포인터 기초
- 변수를 저장하는 방식은 스택 메모리에 있는 특정 주소에 원하는 "값"을 넣는 방식
- 포인터를 이용하면 스택 메모리에 올라가 있는 변수의 원본 수정이 가능 (주소 저장)
- 포인터라는 바구니는 8바이트(64비트 운영체제) 고정 크기
- `*ptr` 을 하면 ptr이라는 주소를 저장하는 바구니가 가리키는 주소로 가서 해당 내용을 꺼내올 수 있다
- `int* ptr=&number` '포인터 주소 값을 타고 가면 int가 있을꺼야'를 전달 
- 하지만 포인터 사용 시 <mark style="background: #FF898996;">타입이 불일치</mark> 할 경우 (`_int64* ptr2 = (_int64*)&number`)
- `*ptr2 = 0x0000AABB CCDDEEFF` 진행할 경우 number는 4바이트인데 2바이트를 추가로 밀어주다 보니  0000AABB가 초과되어 위에 영역까지 차지
- number 변수 자체의 영역을 넘어서 다른 영역까지 덮어쓰고 있는 위험한 상황!
- 이게 경우에 따라 플레이어 골드와 같이 중요한 데이터가 있던 영역이었다면 골드가 갑자기 불어나는 해프닝이 발생할 수 있다
- **포인터를 이용해 주소를 조작할 수 있다 보니 주소를 조금이라도 잘못 인식해서 주소를 넘어가서 사용하게 되면 데이터가 덮어 써지는 문제 발생!!**
```
void SetHp(int *hp)
{
	*hp = 100;
}
int main()
{
	int hp = 1;
	// [매개변수][RET][지역변수(hp 1)]  [매개변수(주소)][RET][지역변수]
	SetHp(&hp);
}
```

***

## 포인터 연산
- #주소연산자(`&`): 해당 변수 타입(TYPE)에 따라서 TYPE* 반환
- #산술연산자(`+, -`)
	1.  nt형 변수는 어떤 정수를 저장하기 위해 사용하기 때문에 1이 증가하면 산술적으로 1이 증가하는 것이 자연스러움
	2. `int*` : 포인터 타입, 8바이트 주소를 담는 바구니, 주소를 따라가면 int(4바이트 정수형 바구니)기 있다고 가정해라
	3. 포인터에서 +나 -등 산술 연산으로 1을 더하거나 빼면 한번에 TYPE 크기만큼 이동하라 의미 (바구니 단위의 이동)
- #간접연산자(`*`)
	1. 포인터가 가리키는 값에 가서 직접 값을 넣어줌 
	2. 포인터는 C++ 관점에서나 묶음이지 어셈블리 언어 관점에서 보면 하나하나 변수를 만들어 준거랑 차이가 없기 때문에 포인터의 경우 두 단계에 거쳐서 데이터 세팅.
	3. 포탈을 타고 이동 시켜주는 부분, 오프셋을 더해주는 부분 (hp 오프셋=0, damage dhvmtpt=4)
	4. `Player* playerPtr = &player;` `(*playerPtr).hp = 200;` `(*playerPtr).damage = 200;`
- #간접멤버연산자(`->`): '`*`'(간접연산자)와 '`.`'(구조체의 특정 멤버를 다룰 때 사용) 을 한 방에 처리. `playerPtr->hp = 200;`  `playerPtr->damage = 200;`

***

### 실습