## 값 전달 / 주소 전달
-  포인터를 쓰지 않으면 내부적으로 지역 변수에 임시적으로 변수를 만들어 준 다음 거기서 값을 세팅하고 최종적으로 값을 _복사_ 방식으로 뱉어주는 번거러움 발생
- <mark style="background: #0E4F9FA6;">StatInfo 구조체가 너무 커질 경우 값 전달의 경우 매개변수가 어마어마하게 많은 데이터를 받아야 하지만 포인터를 이용하여 주소 전달 방식으로 넘겨 받으면 구조체가 아무리 커지더라도 포인터 주소값 자체는 4바이트나 8바이트 고정 크기이기 때문에 아무런 부담이 없다!!</mark>
```cpp
void PrintInfoByPtr(StatInfo info)
{
	cout << "HP: " << info.hp << endl;
	cout << "ATT: " << info.attack << endl;
	cout << "DEF: " << info.defence << endl;
}

void PrintInfoByPtr(StatInfo* info)
{
	cout << "HP: " << info->hp << endl;
	cout << "ATT: " << info->attack << endl;
	cout << "DEF: " << info->defence << endl;
}

int main()
{
	PrintInfoByPtr(info);
	PrintInfoByPtr(&info);
}
```

## 참조 전달(&)
- `int& reference = number;` number라는 바구니에 **reference**라는 다른 이름을 붙여준 것 (별칭)
- <mark style="background: #FF898996;">메모리 공간이 새롭게 할당되는 것이 아니라 변수(할당된 메모리 공간에 붙여진 이름)에 이름이 하나 더 생기는 것 (메모리에 접근할 수 있는 길 2가지)</mark>
- reference 변수에 값을 넣으면 실제 number 변수에 그 값을 넣으면 됨!
- 참조자는 선언과 동시에 누군가를 참조해야 함. 참조의 대상은 기본적으로 변수가 되어야 하고 참조의 대상은 변경할 수 없다
- 변수의 성향을 지니는 대상이라면 참조자의 선언이 가능하다 (배열 요소 역시 변수의 성향을 지니기 때문에 참조자의 선언이 가능)
- 포인터와 동작 방식이 완전히 똑같은데 또 다른 이름을 짓는 이유는?
- <mark style="background: #0E4F9FA6;">값 전달처럼 편리하게 사용하고 주소 전달처럼 주소값을 이용해 접근하는 일석이조의 방식</mark>
- 주소값을 명시적으로 꺼내서 넘길 필요 없이 변수 자체만 매개변수로 넘겨주면 됨
- &가 어떤 변수 앞에 붙으면 주소를 꺼내 달라는 의미고 처음에 어떤 변수를 선언할 때 타입 뒤에 붙는 것은 참조값을 의미
- 매개변수가 존재하기 위해서는 함수가 호출되어야 하는데 함수 호출 과정에서 선언과 동시에 전달되는 대상으로 초기화 되므로 '매개변수에 선언된 참조자'도 선언과 동시에 초기화 된다
- 매개 변수가 참조자로 선언이 되고 인자로 전달되는 값이 변수이면 변수에 저장된 값이 전달되는 것이 아니라 '인자로 전달된 변수를 참조자가 참조'하게 됨
```cpp
void SwapByRef(int &ref1, int &ref2)
{
	int temp = ref1;
	ref1 = ref2;
	ref2 = temp;
} // 빠져나오면 참조자만 사라짐

int main()
{
	int val1 = 10;
	int val2 = 20;
	SwapByRef(val1, val2);
	return 0;
}
```


### 포인터 vs 참조 (차이점)
- 참조는 포인터와 같은 동작을 하지만 인터페이스 자체가 포인터와 다르게 일반적인 복사와 비슷하게 사용한다
1. **편의성**
	- 참조가 편의성이 좀 더 좋지만 편의성이 좋다는 게 꼭 장점 만은 아니다
	- <mark style="background: #FF898996;">포인터는 주소를 넘기니 확실하게 원본을 넘긴다는 힌트를 줄 수 있는데 참조는 자연스럽게 모르고 지나칠 수 있음!</mark>
		- ("실수로 인한 값의 변경이 일어나지 않는다") 참조값을 매개변수로 받은 함수 내에서 <mark style="background: #FFAB45CF;">"실수로 원본 값을 고칠 수 있는 부분"은 "const"를 사용해서 예방 가능</mark> 
		-  ("함수의 원형 선언만 봐도 값의 변경이 일어나지 않음을 판단할 수 있다" ) `void PrintInfoByPtr(const StatInfo& info)` 는 함수 PrintInfoByPtr 내에서 참조자 info를 이용한 값의 변경은 허용하지 않겠다는 의미!
	- 포인터도 매개변수도 const 사용 가능 (복잡...)
		- 별 뒤에 붙인다면? `void PrintInfoByPtr(StatInfo* const info)` info 라는 바구니의 '주소'를 바꿀 수 없음. 주소값이 고정.
		- 별 앞에 붙인다면? `void PrintInfoByPtr(const StatInfo* info)` info가 가리키고 있는 바구니의 '내용물'을 바꿀 수 없음
	
2. **초기화 여부**
	- <mark style="background: #FF898996;">참조 타입은 바구니의 2번째 이름으로 참조하는 대상이 없으면 안되는 반면 포인터는 어떤 주소라는 의미로 대상이 실존하지 않을 수 있음</mark>
	- 포인터가 어떠한 주소도 가리키지 않는다는 의미를 전달하고 싶을 때? `StatInfo* pointer = nullptr`
	- 예를 들어 몬스터를 찾는 함수를 만들었을 때 `StatInfo* FindMonster()` 라는 함수를 만들었을 때 Heap 영역에서 뭔가를 찾는데 찾지 못했을 때 return nullptr과 같이 사용 가능
	- 그래서 <mark style="background: #FFAB45CF;">포인터를 쓸 때는 null 값이 들어있을 수 있으므로 항상 예외처리를 해주기!</mark> `if (info == nullptr) return;`
	- (없는 경우도 고려해야 한다면 pointer을 써서 null 체크, 바뀌지 않고 읽는 용도 readonly만 사용하면 conset ref&)
	```cpp
	int main()
	{
		StatInfo* pointer;
		pointer = &info;
		PrintInfo(pointer);

		StatInfo& reference = info;
		PrintInfo(reference);
	}
	```
	3. 기타 지식
		- 포인터로 사용하던 걸 참조로 넘겨주려면? `PrintInfoByRef(*pointer);`  `void PrintInfoByRef(const StatInfo& info)`
		- 참조로 사용하던 걸 포인터로 넘겨주려면? ``PrintInfoByPtr(&reference);``    `void PrintInfoByPtr(const StatInfo* info)`