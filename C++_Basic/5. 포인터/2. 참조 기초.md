## 값 전달 / 주소 전달
-  포인터를 쓰지 않으면 내부적으로 지역 변수에 임시적으로 변수를 만들어 준 다음 거기서 값을 세팅하고 최종적으로 값을 _복사_ 방식으로 뱉어주는 번거러움 발생
- <mark style="background: #0E4F9FA6;">StatInfo 구조체가 너무 커질 경우 값 전달의 경우 매개변수가 어마어마하게 많은 데이터를 받아야 하지만 포인터를 이용하여 주소 전달 방식으로 넘겨 받으면 구조체가 아무리 커지더라도 포인터 주소값 자체는 4바이트나 8바이트 고정 크기이기 때문에 아무런 부담이 없다!!</mark>
```cpp
void PrintInfoByPtr(StatInfo info)
{
	cout << "HP: " << info.hp << endl;
	cout << "ATT: " << info.attack << endl;
	cout << "DEF: " << info.defence << endl;
}

void PrintInfoByPtr(StatInfo* info)
{
	cout << "HP: " << info->hp << endl;
	cout << "ATT: " << info->attack << endl;
	cout << "DEF: " << info->defence << endl;
}

int main()
{
	PrintInfoByPtr(info);
	PrintInfoByPtr(&info);
}
```

## 참조 전달(&)
- `int& reference = number;` number라는 바구니에 reference라는 다른 이름을 붙여준 것
- reference 변수에 값을 넣으면 실제 number 변수에 그 값을 넣으면 됨!
- 포인터와 동작 방식이 완전히 똑같은데 또 다른 이름을 짓는 이유는?
- 값 전달처럼 편리하게 사용하고 주소 전달처럼 주소값을 이용해 접근하는 일석이조의 방식
- 주소값을 명시적으로 꺼내서 넘길 필요 없이 변수 자체만 매개변수로 넘겨주면 됨
- &가 어떤 변수 앞에 붙으면 주소를 꺼내 달라는 의미고 처음에 어떤 변수를 선언할 때 타입 뒤에 붙는 것은 참조값을 의미
```cpp
void PrintInfoByPtr(StatInfo& info)
{
	cout << "HP: " << info.hp << endl;
	cout << "ATT: " << info.attack << endl;
	cout << "DEF: " << info.defence << endl;
}

int main()
{
	PrintInfoByPtr(info);  // 참조전달
}
```


### 포인터 vs 참조 (차이점)
- 참조는 포인터와 같은 동작을 하지만 인터페이스 자체가 포인터와 다르게 일반적인 복사와 비슷하게 사용한다
1. **편의성**
	- 참조가 편의성이 좀 더 좋지만 편의성이 좋다는 게 꼭 장점 만은 아니다
	- 포인터는 주소를 넘기니 확실하게 원본을 넘긴다는 힌트를 줄 수 있는데 참조는 자연스럽게 모르고 지나칠 수 있음!
		- 참조값을 매개변수로 받은 함수 내에서 <mark style="background: #FFAB45CF;">마음대로 원본 값을 고칠 수 있는 부분은 const를 사용해서 예방 가능</mark> `void PrintInfoByPtr(const StatInfo& info)`
	- 포인터도 매개변수도 const 사용 가능 (복잡...)
		- 별 뒤에 붙인다면? `void PrintInfoByPtr(StatInfo* const info)` info 라는 바구니의 주소를 바꿀 수 없음. 주소값이 고정.
		- 별 앞에 붙인다면? `void PrintInfoByPtr(const StatInfo* info)` info가 가리키고 있는 바구니의 내용물을 바꿀 수 없음
	
2. **초기화 여부**
	- 참조 타입은 바구니의 2번째 이름으로 참조하는 대상이 없으면 안됨
	- 반면 포인터는 어떤 주소라는 의미로 대상이 실존하지 않을 수 있음
	- 포인터가 어떠한 주소도 가리키지 않는다는 의미를 전달하고 싶을 때? `StatInfo* pointer = nullptr`
	- 예를 들어 몬스터를 찾는 함수를 만들었을 때 `StatInfo* FindMonster()` 라는 함수를 만들었을 때 Heap 영역에서 뭔가를 찾는데 찾지 못했을 때 return nullptr과 같이 사용 가능
	- 그래서 <mark style="background: #FFAB45CF;">포인터를 쓸 때는 null 값이 들어있을 수 있으므로 항상 예외처리를 해주기!</mark> `if (info == nullptr) return;`
	- (없는 경우도 고려해야 한다면 pointer을 써서 null 체크, 바뀌지 않고 읽는 용도 readonly만 사용하면 conset ref&)
	```cpp
	int main()
	{
		StatInfo* pointer;
		pointer = &info;
		PrintInfo(pointer);

		StatInfo& reference = info;
		PrintInfo(reference);
	}
	```
	3. 기타 지식
		- 포인터로 사용하던 걸 참조로 넘겨주려면? `PrintInfoByRef(*pointer);`  `void PrintInfoByRef(const StatInfo& info)`
		- 참조로 사용하던 걸 포인터로 넘겨주려면? ``PrintInfoByPtr(&reference);``    `void PrintInfoByPtr(const StatInfo* info)`