## 메모리 구조
- 코드 영역: 실행할 코드가 저장되는 영역
- 데이터 영역: 전역(global)/정적(static) 변수가 저장. 프로그램 시작과 동시에 들어갈 내용 결정. 프로그램 종료 시 내려옴.
- 스택 영역: 지역 변수/매개 변수가 저장. 실행 과정에서 메모리 **자동** 할당 및 소멸  #암기
- 힙 영역:  동적 할당? #암기
	- 실제 상황에서 스택은 어마어마하게 많은 데이터를 저장하는 용도로 만들어진 것이 아니라 함수들끼리 인자를 좀 더 자연스럽게 전달하는 용도
	- 스택 영역에서 데이터가 많아지면 스택 오버플로우가 일어남
	- 스택이나 데이터 영역은 항상 최대 상한선에 맞춰서 메모리를 잡아줘야 한다는 아쉬운 문제
	- 스택 영역은 함수가 함수가 끝나면 같이 정리되는 불안정한 메모리로 잠시 함수에 매개변수를 넘기는 용도로는 좋지만 다량의 몬스터 생성에는 부적합
	- 메모리 영역은 프로그램이 실행되는 도중에는 '무조건' 사용되는 영역으로 계속 들고 있어야 하므로 다량의 데이터를 넣기에는 부적합
	- 그럼 <mark style="background: #FF898996;">유동성 있게 필요한 만큼만 메모리를 쓰고 필요 없어지면 반환할 수 있는 메모리</mark> 필요, 그러면서도 (스택과는 다르게) 우리가 생성/소멸 시점을 관리할 수 있는 메모리 필요!!
	- 그게 바로 **힙 영역** (**수동** 할당 및 소멸)
```cpp
int main()
{
	// 유저 영역 [메모장]  [LOL]  [플레이어] 일반적 프로그램(독립적)
	// -------------------------------------------------------
	// 커널 영역 (Windows 등의 핵심 코드가 돌아가고 있는 상태)

	// LOL에서 새로운 미니언이 탄생해서 메모리 할당해서 만들어줘야 할 때
	// 자기가 멋대로 메모리 조작시 롤에 의해 다른 메모장 등의 애들까지 건들이면 큰일
	// 그래서 유저 영역에서 실행되는 프로그램은 서로 완전히 독립적
	// 그리고 메모리는 롤이 직접 관리하는 개념이 아니라 커널 영역에 요청 후 허락 필요
	// 유저 영역) 운영체제에서 제공하는 API(함수) 호출, 메모리 요청
	// 커널 영역) 메모리를 할당해서 건내줌
	// 유저 영역) ㄳㄳ 잘 쓸게요~

	// 메모리를 요청할 때 메모리를 큼지막하게 받아두고 이걸 쪼개서 사용
	// 힙 영역도 딱 한 개만 받는게 아니라 여러 개를 받아서 잘라서 쓰는 개념
	// C++에서는 기본적으로 CRT(c런타임 라이브러리)의 [힙 관리자]를 통해 힙 영역 사용
	// 단, 정말 원한다면 직접 API를 통해 힙을 생성하고 관리할 수 있음 (MMORPG 서버 메모리 풀링)
	
	Knight knight;   // 스택에 만들기
	Knight* k2 = new Knight();   // 힙에 만들기

	return 0;
}
```


***


## 동적 할당과 연관된 함수/연산자
- `malloc, free, new, delete, new[], delete[]`
- malloc /  free
	- **malloc**은 할당할 **메모리 크기**를 건네준다
	- 메모리 할당 후 시작 주소를 가리키는 포인터를 반환해준다 (메모리 부족 시  NULL 반환)
	- 잠깐!! `void*`?? 포인터를 타고 가면 void 뭐가 있는지 모르겠으니까 (어떻게 사용할지 지정을 해주는 상태가 아니니까) 너가 적당히 변환해서 사용해라 #void포인터
	- **free**는 malloc을 통해 할당된 영역을 해제한다
	- 힙 관리자가 할당/미할당 여부를 구분해서 관리
	- 메모리를 해제 할 때는 malloc처럼 sizeof로 사이즈 정보를 전달해 주지 않아도 된다 -> 힙 관리자에게 메모리 요청을 하면 딱 그 만큼만 떼어주는 게 아니라 <mark style="background: #0E4F9FA6;">몇 바이트를 사용했는지 정보도 헤더에 넣어서 같이 전해줌</mark>. 그래서 free 를 할 때 몇 바이트인지 입력을 안해도 잘 찾아서 메모리를 날릴 수 있다
- 문제 상황!
	- '*Heap Overflow*': 유효한 힙 범위를 초과해서 사용하는 문제
	- free를 해주지 않으면 '메모리 누수' 현상 발생 (메모리 여유분이 없어서 프로그램이 뻗는 상태)
	- '*Double Free*': free를 여러 번 하는 문제. 크래시만 나고 끝나는 경우 99%
	- '*Use-After-Free*': `void* pointer = malloc(sizeof(Monster))` 메모리를 반납해도 포인터 자체가 없어진 게 아니기 때문에 포인터 변수를 통헤 이 주소에 계속 접근 가능. 엉뚱한 메모리를 계속 건드릴 수 있음 `pointer = nullptr;` 을 통해 예방
```cpp
class Monster
{
public:
	int _hp;
	int _x;
	int _y;
};


int main()
{
	// typedef a b; 는 a라는 타입한테 b라는 이름으로도 사용하게끔 만들어준다는 의미
	// malloc(size_t)에서 size_t는 typedef unsigned int size_t; 
	void* pointer = malloc(sizeof(Monster));
	
	Monster* m1 = (Monster*)pointer;
	m1->_hp = 100;
	m1->_x = 1;
	m1->_y = 2;

	free(pointer);
	pointer = nullptr;

	return 0;
}
```
- new / delete
	- malloc/free 함수! new/delete는 **연산자(operator)**
	- `new[]` / `delete[]` 는 new가 malloc에 비해 좋긴 한데 배열과 같이 n개 데이터를 같이 할당하려면 사용
	- `new[]` 를 `delete[]`로 생성된 만큼 날려주기 (짝 맞추기)
```cpp
class Monster
{
public:
	Monster()
	{
		cout << “Monster()” << endl;
	}
	~Monster()
	{
		count << “~Monster()” << endl;
	}

public:
	int _hp;
	int _x;
	int _y;
};


int main()
{
	Monster* m2 = new Monster; 
	Monster& ref = *m2;  // 참조자를 이용한 힙 접근 가능!!
	ref._hp = 100;
	
	m2->_hp = 200;
	m2->_x = 2;
	m2->_y = 3;
	delete m2;

	Monster* m3 = new Monster[5]; // 여러 마리를 동시에 만들어주는 문법
	m3->_hp = 200;
	m3->_x = 2;
	m3->_y = 3;
	delete[] m3;

	Monster* m4 = (m3 + 1);
	m4->_hp = 300;
	m4->_x = 4;
	m4->_y = 5;
	delete[] m4;

	return 0;
}
```
- 둘의 가장 근본적인 차이는?
	- 편의성 측면은 new/delete 가 유리하지만 타입에 상관 없이 특정한 크기의 메모리 영역을 할당 받으려면? malloc/free 가 승리
	- <mark style="background: #FFAB45CF;">new/delete는 (생성 타입이 클래스 일 경우) 생성자/소멸자를 호출해준다</mark> #암기
		- malloc에서 `Monster* m1 = (Monster*)pointer;`는 우리가 강제로 몬스터라고 간주해서 pointer를 사용하겠다는 거지 몬스터를 만들었다는 내용은 어디에도 없기 때문에 몬스터의 생성자는 호출되지 않는다 (메모리만 할당할게 느낌, 객체와 연관 지어서 생성자를 호출하는 개념은 아님)
		- new에서 `Monster* m2 = new Monster`는 몬스터 생성자가 애를 만들어준 동시에 몬스터 생성자가 간접적으로 호출한다
	