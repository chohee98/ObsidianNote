## 얕은 복사 vs 깊은 복사
- #암기 
1. 얕은 복사(Shallow Copy)
	- 멤버 데이터를 비트열 단위로 '똑같이' 복사 (메모리 영역 값을 그대로 복사)
	- 포인터는 주소값 바구니인데 주소값을 똑같이 복사하면 동일한 객체를 가리키는 상태가 된다
	- 여러 개의 객체가 동일한 객체를 가리키고 있기 때문에 소멸자 호출 시 두 번째 소멸자부터 이미 없는 얘를 소멸 시키려고 하기 때문에 문제 (더블 프리 에러)
2. 깊은 복사(Deep Copy)
	- 멤버 데이터가 참조(주소) 값이라면, 데이터를 새로 만들어준다 (원본 객체가 참조하는 대상까지 새로 만들어서 복사)
	- 포인터는 주소값 바구니니까 새로운 객체를 생성해서 상이한 객체를 가리키는 상태로
	- 복사 생성자나 복사 대입 연산자를 그대로 사용하지 않고 오버로딩을 이용하여 명시적으로 생성자 만들기
	- 어떤 클래스에 포인터나 참조가 있다면 깊은 복사 먼저 생각하기

![[얕은복사&깊은복사.png]]

```cpp
class Pet
{
public:
	Pet()
	{
		cout << "Pet()" << endl;
	}
	~Pet()
	{
		cout << "~Pet()" << endl;
	}
	Pet(const Pet& pet)
	{
		cout << "Pet(const Pet&)" << endl;
	}
};

class Knight
{
public:
	Knight() // 얕은 복사 테스트
	{
		_pet = new Pet();	
	}

	Knight(const Knight& knight) // 깊은 복사 테스트
	{
		_hp = knight._hp;
		//_pet = knight._pet;	// 얕은 복사 방식
		// 나이트가 들고 있는 _pet은 포인터 타입이다 보니 
		// *을 붙여 주소로 가서 복사 해주듯 사용 *(knight._pet)
		_pet = new Pet(*knight._pet); // 핵심!!
	}

	Knight& operator=(const Knight& knight) // 깊은 복사 테스트
	{
		_hp = knight._hp;
		_pet = new Pet(*knight._pet);
		return *this;
	}

	~Knight()
	{
		delete _pet;
	}

public:
	int _hp = 100;
	// Pet _pet;
	// 펫이 나이트의 멤버변수로 있으면 나이트 생성시 같이 생성되고 소멸시 같이 소멸되는 문제
	// 생명 주기 관리가 어려워짐
	// 펫의 데이터가 커지면 나이트도 같이 비대해지는 문제
	// 더 큰 문제는 펫을 상속 받은 다른 클래스가 생기면 여기에 Pet을 넣을 수 없음
	// 그러니 포인터로 만들어주자!
	Pet* _pet;
};

int main()
{
	//Pet* pet = new Pet();	// 힙 영역 (얕은 복사 테스트)

	Knight knight;		// 기본 생성자
	knight._hp = 200;
	//knight._pet = pet;	// 나이트가 1번 펫을 갖고 있는 상태 (얕은 복사 테스트)

	// Knight knight2(knight); 복사 생성자 개입, knight와 똑같은 펫을 지니게는 됨(공유중)
	Knight knight2 = knight;	

	Knight knight3;		// 기본 생성자
	// 복사 대입 연산자 개입, 기사는 셋이지만 펫은 한마리를 공유하고 있는 상태...
	knight3 = knight;	

	// 복사 생성자와 복사 대입 연산자는
	// 둘 다 직접 안만들어주면 컴파일러가 '암시적으로!!!!!' 만들어준다
	// 컴파일러가 암시적으로 만들어 준 버전은 메모리에 있는 데이터를 그대로 복사해 준다는 특징 
	// = (얕은 복사)
	
	// 얕은 복사
	// Stack : knight [ hp 0x1000 ] -> Heap 0x1000 Pet[  ]
	// Stack : knight2 [ hp 0x1000 ] -> ``
	// Stack : knight3 [ hp 0x1000 ] -> ``

	// 깊은 복사 (자신만의 고유한 펫 동적 할당)
	// Stack : knight [ hp 0x1000 ] -> Heap 0x1000 Pet[  ]
	// Stack : knight2 [ hp 0x2000 ] -> Heap 0x2000 Pet[  ]
	// Stack : knight3 [ hp 0x3000 ] -> Heap 0x3000 Pet[  ]
	return 0;
}
```


### 실험
- 암시적 복사 생성자 Steps Rule
	1. 부모 클래스의 복사 생성자 호출
	2. 멤버 클래스의 복사 생성자 호출
	3. 멤버가 기본 타입일 경우 메모리 복사 (얕은 복사)
- 명시적 복사 생성자 Steps Rule
	1. 부모 클래스의 복사 생성자 호출
	2. 멤버 클래스의 기본 생성자 호출 (우리한테 책임)
- 암시적 복사 대입 연산자 Steps Rule
- 명시적 복사 대입 연산자 Steps Rule
