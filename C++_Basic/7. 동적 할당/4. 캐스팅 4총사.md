#암기
## 캐스팅 (타입 변환)  😀
1. **static_cast** (사용 빈도가 가장 높음) : 타입 원칙에 비춰볼 때 상식적인 캐스팅만 허용
	- int <-> float
	-  Player* -> Knight* (다운캐스팅)   << 단, 안정성은 보장 못함
```cpp
class Player
{  };

class Knight : public Player
{  };

int main()
{
	// static_cast
	int hp = 100;
	int maxHp = 200;
	float ratio = static_cast<float>(hp) / maxHp;
	
	Player* p = new Knight();
	Knight* k1 = static_cast<Knight*>(p);

	// p가 바로 위에서 등장한게 아니라 저 멀리서 만들어져서 알기 힘들 경우
	// 다이나믹 캐스트를 이용하거나
	// 플레이어에 플레이어 타입을 넣어줘서 체크를 하고 맞으면 스태틱 캐스팅으로 변환
	return 0;
}
```


2. **dynamic_cast** : <mark style="background: #FF898996;">상속 관계</mark>에서의 안전 형변환
	- RTTI (RunTime Type Information) : 실시간으로 코드가 동작할 때 타입을 확인할 수 있는 기법 (virtual을 이용하여 가상 함수 테이블을 만들고 어떤 가상 함수를 참조해야 하는지 확인)
	- 다형성을 활용하는 방식
	- vitrual 함수를 하나라도 만들면 객체의 메모리에 가상 함수 테이블 주소가 기입
	- 만약 <mark style="background: #FFAB45CF;">잘못된 "타입"으로 캐스팅을 했으면, nullptr 반환!!</mark> (static_cast과 달리)
	- 이를 이용해서 맞는 타입으로 캐스팅을 했는지 확인할 때 유용
	- 대신 확인하는 작업 때문에 static_cast보다 조금 느림
```cpp
class Player
{
public:
	virtual ~Player() { }
};

class Knight : public Player
{
public:
};

class Archer : public Player
{
public:
};

int main()
{
	// dynamic_cast
	int hp = 100;
	int maxHp = 200;
	float ratio = static_cast<float>(hp) / maxHp;
	
	Player* p = new Knight();
	Knight* k2 = dynamic_cast<Knight*>(p);

	return 0;
}
```


3. **const_cast** : const를 붙이거나 때거나
	- `PrintName(const_cast<char*>("Rookiss"));`


4. **reinterpret_cast** : 가장 위험하고 강력한 형태의 캐스팅
	- 're-interpret' : 다시-간주하다/생각하다
	- 포인터랑 전혀 관계없는 다른 타입 변환 등에 사용
	- static_cast나 dynamic_cast는 두 클래스 사이 상속 관계가 있을 때 활용하지만 reinterpret_cast는 아무 관계가 없어도 가능
