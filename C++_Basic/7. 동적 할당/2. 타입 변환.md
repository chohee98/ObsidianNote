`이전에 malloc->void*을 반환하고, 이를 '타입 변환'을 통해 사용했었음 `

## 타입 반환 유형
### 비트열 재구성 여부
1. 값 타입 반환
	- 특징) _의미를 유지_ 하기 위해서, 원본 객체와 다른 비트열 구성 (논리적으로 생각)
2. 참조 타입 반환
	- 특징) 비트열을 재구성하지 않고, _관점_ 만 바꾸는 것
	- 만들어진 형태만을 빠르게 해석
	- 데이터 자체는 똑같이 유지하고 있지만 데이터를 바라보는 관점이 변해서 아예 엉뚱한 의미를 갖게 됨
	- 거의 쓸 일이 없지만, 포인터 타입 변환도 '참조 타입 변환'과 동일한 룰을 따르니까 일석이조로 공부하자!
```cpp
int main()
{
	// 값 타입 변환
	{
		int a = 123456789;	// 2의 보수
		float b = (float)a;	// 부동소수점(지수+유효숫자)
		cout << b << endl;
	}

	// 참조 타입 변환
	{
		int a = 123456789;
		float b = (float&)a;
		cout << b << endl;
	}

	return 0;
}
```


### 안전도 분류
1. 안전한 변환
	- 특징) 의미가 항상 100% 완전히 일치하는 경우
	- 같은 타입이면서 크기만 더 큰 바구니로 이동하는 경우 (_업캐스팅_)
2. 불안전한 변환
	- 특징) 의미가 항상 100% 일치한다고 보장하지 못하는 경우
	- 타입이 다르거나 같은 타입이지만 큰 바구니 -> 작은 바구니 이동 (_다운캐스팅_)
```cpp
int main()
{
	// 안전한 변환
	{
		int a = 123456789;
		_int64 b = a;
		cout << b << endl;
	}

	// 불안전한 변환
	{
		int a = 123456789;
		float b = a;
		short c = a;
		cout << b << endl;
		cout << c << endl;
	}
	
	return 0;
}
```


### 프로그래머 의도에 따라 분류 
1. 암시적 변환 #암기
	- 특징) 이미 알려진 타입 변환 규칙에 따라서 _컴파일러가 자동_ 으로 변환
	- 주로 데이터 형식이 호환 가능한 경우에 발생하며, 예를 들어 정수를 부동 소수점으로 자동 변환하는 경우
2. 명시적 변환 #암기
	- 특징) 프로그래머가 명시적으로 _형 변환을 요청_ 하는 것
	- 데이터 손실이 발생할 수 있거나, 명시적으로 변환을 통해 정밀한 제어가 필요한 경우 사용
	- 주로 프로그래머의 의도를 명확히 표현하고자 할 때 사용
```cpp
int main()
{
	// 암시적 변환
	{
		int a = 123456789;
		float b = a;
		cout << b << endl;
	}

	// 명시적 변환
	{
		int a = 123456789;
		int* b = (int*)a;
		cout << b << endl;
	}
	
	return 0;
}
```


### 아무런 연관 관계가 없는 클래스 사이의 변환
1. 연관 없는 클래스 사이의 '값 타입' 변환
	- 의미를 유지한 채로 변환 시도, 두 클래스 사이 아무 연관성이 없으면 통과x
	- 특징) 일반적으로 안 됨 (예외: 타입 변환 생성자, 타입 변환 연산자)
2. 연관 없는 클래스 사이의 참조 타입 변환
	- 포인터로 분석을 하면 주소를 타고 가면 무엇인가 있었다는 그냥 애매한 주장을 우리가 하고 있는 거에 불과하기 때문에 통과
	- 단 엉뚱한 메모미를 참조해서 메모리를 침범하는 문제가 생길 수 있기 때문에 조심
	- 특징) 명시적으로는 OK
```cpp
class Knight
{
public:
	int _hp = 10;
};

class Dog
{
public:
	Dog(const Knight& knight)  // 타입 변환 생성자
	{
		_age = knight._hp;
	}

	operator Knight()  // 타입 변환 연산자
	{
		return (Knight)(*this);
	}

public:
	int _age = 1;
	int _cuteness = 2;
};

int main()
{
	// 연관 없는 클래스 사이의 '값 타입' 변환
	{
		Knight knight;
		Dog dog = (Dog)knight;	// 타입 변환 생성자
		Knight knight2 = dog;	// 타입 반환 연산자
	}

	// 연관 없는 클래스 사이의 참조 타입 변환
	{
		Knight knight;
		// 이렇게 참조를 하면 얘가 엉뚱하게 메모리를 초과해서 사용하는 문제 발생
		Dog& dog = (Dog&)knight;
		// 이러면 건드리면 안되는 메모리를 건들이게되는 문제 발생
		// 그럼 왜 이 문법이 통과되는 걸까?
		dog._cuteness = 12;

		// 어셈블리 관점: 포인터 = 참조
		// 포인터로 분석을 하면 주소를 타고 가면 지금 개가 있다고 주장
		// 이렇게 주장하는 것이 진짜 맞지 않아도 문법적으로 아무 문제가 없기 때문에 
		// 형식 자체는 유효
		// 포인터는 이런 상황이 비일비제하게 일어남 (일단은 여유롭게 통과시켜 줌)

		// 반면 타입 변환 생성자는 데이터를 통으로 복사해서 넣어주는 형식이기 때문에 
		// 엄격하게 체크 -> 타입 변환 생성자, 타입 변환 연산자를 이용해야 함
	}
	return 0;
}
```


### 상속 관계에 있는 클래스 사이의 변환
1. 상속 관계 클래스의 값 타입 변환
	- 불독에서 개로 넘어가려고 했으면 일부 데이터가 딸린 채로 나머지 필요한 데이터만 적절히 넣어 줘서 변환 가능
	- 특징) 자식->부모 ok  /  부모->자식 no
2. 상속 관계 클래스의 참조 타입 변환
	- 특징) 자식->부모 ok  /  부모->자식 (암시적no) (명시적ok)
	- 안전하다고 판단이 되면 직접적으로 명시하지 않아도 자연스럽게 변환 가능
```cpp
class Dog
{
public:
	Dog()
	{
	}
	Dog(const Knight& knight)  	// 타입 변환 생성자
	{
		_age = knight._hp;
	}
	operator Knight()  	// 타입 변환 연산자
	{
		return (Knight)(*this);
	}

public:
	int _age = 1;
	int _cuteness = 2;
};

class BullDog : public Dog
{
public:
	bool _french; // 프렌치 불독
};

int main()
{
	// 상속 관계 클래스의 값 타입 변환
	{
		//Dog dog;
		//BullDog bulldog = dog;	// 변환 실패

		BullDog bulldog;
		Dog dog = bulldog;
	}

	// 상속 관계 클래스의 참조 타입 변환
	{
		//Dog dog;
		//BullDog& bulldog = (BullDog&)dog;// 되긴 하는데 위험, 명시적으로 변환을 해줘야 함

		BullDog bulldog;
		Dog& dog = bulldog;	// 암시적으로 해도 컴파일 성공
	}
	return 0;
}
```


### 결론
- 값 타입 변환: 진짜 비트열도 바꾸고, 논리적으로 말이 되게 바꾸는 연산
- _참조 타입 변환_: 비트열은 냅두고 우리의 '관점'만 바꾸는 변환 -> 명시적으로 요구하면 해주기는 하는데 암시적으로 해주는지는 안전성 여부와 연관이 있음 (메모리 침범 위험이 있는 경우는 암시적으로 해주진 않음)


***


## 복습
```cpp
class Item
{
public:
	Item()
	{
		cout << "Item()" << endl;
	}

	Item(const Item& item)
	{
		cout << "Item(const Item&)" << endl;
	}

	~Item()
	{
		cout << "~Item()" << endl;
	}

public:
	int _itemType = 0;
	int _itemDbld = 0;

	char _dummy[4096] = {};	// 이런 저런 정보들로 인해 비대해진
};

void TestItem(Item item) // 얘도 객체이기 때문에 호출이 되서 만들어지고 소멸될 때 소멸자 호출
{

}

void TestItemPtr(Item* item)
{

}

int main()
{
	// 복습
	{
		// Stack [ type(4) dbid(4) dummy(4096) ]
		// 영역 밖으로 나가면 자동으로 소멸자 호출
		Item item;

		// Stack [ 주소(4-8) ] -> Heap 주소 [ type(4) dbid(4) dummy(4096) ]
		// 영역 밖으로 나가도 주소값을 참조해서 원본은 저 멀리 있는 개념이기 때문에
		// 소멸자를 호출하지 않음
		Item* item2 = new Item();

		TestItem(item);
		TestItem(*item2);

		TestItemPtr(&item);
		TestItemPtr(item2);

		// item2에 대해 delete를 하지 않으면 메모리 누수(Memory Leak) 발생
		// 점점 가용 메모리가 줄어들어서 Crash
		delete item2;
	}

	// 배열
	{
		cout << "-----------------------------------" << endl;

		// 진짜 아이템 100개가 스택 메모리에 올라가 있는 것
		Item item3[100] = {};

		cout << "-----------------------------------" << endl;

		// 아이템을 가리키는 바구니가 100개. 실제 아이템은 1개도 없을 수 있다
		Item* item4[100] = {};

		for (int i = 0; i < 100; i++)
			item4[i] = new Item();

		for (int i = 0; i < 100; i++)
			delete item4[i];
	}
	
	return 0;
}
```


***


### 타입 변환 (포인터)
- 명시적으로 타입 변환할 때는 항상 항상 조심해야 한다!
- 암시적으로 될 때는 안전하다?
- 평생 명시적으로 타입 변환(캐스팅)은 안 하면 되는거 아닌가?
- **결론**
	- (포인터) vs (일반 타입) 변수 차이 이해하기
	- 포인터 사이의 타입 변환(캐스팅)을 할 때는 매우 조심해야 한다! -> 여러 클래스들을 최상위 타입으로 바꿔서 저장하고 싶을 때 (인벤토리 케이스처럼) 부모 타입에서 자식 클래스로 변환도 하고 반대로 하면서 왔다 갔다 하는 일이 자주 발생
	- <mark style="background: #FFAB45CF;">부모-자식 관계에서 부모 클래스의 소멸자에는 까먹지 말고 virtual을 붙이자!!</mark>
	- <mark style="background: #FF898996;">(이유!)</mark> "상속 관계에 의해 함수를 재정의 해봤자 어떤 타입에 따라 가지고 어떤 한 애만 자동으로 골라가지고 실행이 되기 때문에 virtual을 붙여주게 되면 가상함수 테이블이 만들어지게 되면서 실제 객체가 뭐로 만들어젔나에 따라가지고 그 함수를 찾아서 호출" #암기

```cpp
class Item  // 부모 함수
{
public:
	Item()
	{
		cout << "Item()" << endl;
	}

	Item(int itemType) : _itemType(itemType)
	{
		cout << "Item(int itemType)" << endl;
	}

	Item(const Item& item)
	{
		cout << "Item(const Item&)" << endl;
	}

	virtual ~Item()
	{
		cout << "~Item()" << endl;
	}

public:
	int _itemType = 0;
	int _itemDbld = 0;

	char _dummy[4096] = {};	// 이런 저런 정보들로 인해 비대해진
};

enum ItemType
{
	IT_Weapon = 1,
	IT_ARMOR = 2,
};

class Weapon : public Item
{
public:
	Weapon() : Item(IT_Weapon)
	{
		cout << "Weapon()" << endl;
		_damage = rand() % 100;
	}
	~Weapon()
	{
		cout << "~Weapon()" << endl;
	}

public:
	int _damage = 0;
};

class Armor : public Item
{
public:
	Armor() : Item(IT_ARMOR)
	{
		cout << "Armor()" << endl;
	}
	~Armor()
	{
		cout << "~Armor()" << endl;
	}

public:
	int _defence = 0;
};


int main()
{
	// 부모-> 자식 변환 테스트
	{
		Item* item = new Item();
		// 메모리가 작은 것에서 큰 걸로 캐스팅하면 엉뚱한 메모리를 건드릴 수 있음
		// Weapon* weapon = item;  // 에러
		/*Weapon* weapon = (Weapon*)item;
		weapon->_damage = 10;	// 에러 (메모리 관련) */

		delete item;
	}

	// 자식 -> 부모 변환 테스트
	{
		Weapon* weapon = new Weapon();
		// 암시적으로도 가능
		Item* item = weapon;

		delete weapon;
	}

	Item* inventory[20] = {};

	srand((unsigned int)time(nullptr));
	// Weapon, Armor를 관리할 수 있는 최상위 부모 클래스 inventory로 바꿔서 관리!!!
	for (int i = 0; i < 20; i++)
	{
		int randValue = rand() % 2;
		switch (randValue)
		{
		case 0:
			inventory[i] = new Weapon();
			break;
		case 1:
			inventory[i] = new Armor();
			break;
		}
	}

	for (int i = 0; i < 20; i++)
	{
		Item* item = inventory[i];
		if (item == nullptr)
			continue;
		if (item->_itemType == IT_Weapon)
		{
			// 위에 조건문 덕분에 어느정도는 안전
			Weapon* weapon = (Weapon*)item;
			cout << "WeaponDamage : " << weapon->_damage << endl;
		}
	}

	// ********************** 매우 매우 매우 중요!!! **********************
	// 상속 관계에서 함수 호출
	// 자식 클래스에서 함수를 재정의 했을 때 부모 함수의 포인터로 그 함수를 호출했을 때
	// 부모 함수의 형식을 따라가서 재정의된 함수가 아닌 부모의 함수가 호출
	// 이렇게 되는 것을 막고 원본 객체 타입에 따라 호출되기를 원하면 virtual 문법 사용
	// 가상 함수 테이블을 만들어서 실행될 함수가 몇 번인지를 관리
	// 이렇게 되면 클래스의 맨 앞에 가상 함수 테이블의 주소가 잡힘
	// 가상 함수를 이용하면 우리가 원하는 원본 타입의 함수 호출 가능
	// 생성자나 소멸자도 같은 룰을 따르게 됨
	// 최상위 부모님의 소멸자에 virtual을 붙여주면 소멸자 자체도 가상함수로 인식되어
	// 명시적으로 하나씩 다 바꿔줄 필요 없이 원본 자체 타입에 맞는 소멸자를 호출해 주게 됨
	
	for (int i = 0; i < 20; i++)
	{
		Item* item = inventory[i];
		if (item == nullptr)
			continue;

		/*// weapon 소멸자를 호출한 뒤에 item 소멸자를 호출해야 깔끔하게 정리가 됨
		if (item->_itemType == IT_Weapon)
		{
			Weapon* weapon = (Weapon*)item;
			delete weapon;
		}
		else
		{
			Armor* armor = (Armor*)item;
			delete armor;
		}*/
		delete item;
	}
	return 0;
}
```