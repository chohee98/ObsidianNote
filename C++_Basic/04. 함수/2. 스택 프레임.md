> C++은 우리가 직접 메모리를 조작할 수 있기 때문에 스택 영역을 엉뚱한 값으로 조작 했다고 하면 리턴하다 크래시가 날 수 있으니 항상 주의!

## 스택 프레임 😡
- 스택 영역에 함수를 구분하기 위해 생성되는 공간으로써 매개변수, 반환 주소값, 지역변수 등을 포함하고 있으며 함수 호출 시 생성되고 함수가 종료되면서 소멸한다
- 메모리 안에는 용도에 따라 코드 영역. 데이터 영역, 힙 영역, 스택 영역 존재한다
- 스택은 높은 메모리 주소에서 낮은 메모리 주소로 할당되며 후입선출(LIFO) 방식으로 데이터가 이동한다
- 스택 메모리가 실질적으로 새로 할당 받는 방식이 아닌 프로그램이 실행될 때 이미 정해져 있는 운영체제가 우리에게 얼마 만큼의 스택을 활용할 수 있다는 것을 정해주고 이걸 함수들끼리 쪼개서 '난 여기까지 사용할 꺼야' 하고 남은 영역을 넘겨준다 (<mark style="background: #824CB496;">함수들끼리 데이터를 주고 받을 때 사용하는 메모장</mark>)
- 반환 주소 값을 넣어주는 이유는 함수 호출이 완료되었을 때 어디로 돌아와야 하는지 기입해야 하기 때문이다

	![[스택프페임1.png|330]]  	![[스택프페임2.png|300]]


### 실습으로 확인해보기..
```cpp
// x86 32비트로 놓고 확인해보기
// 어셈블리어를 디버깅 할 때는 f11 f12 이용

void PrintNumber(int num)
{
	cout << "result: " << num << endl;
}

int MultiflyBy(int a, int b)
{
	int c = a * b;
	return c;
}

int main()
{
	int a = 3;
	int b = 5;
	int result = MultiflyBy(b, a);

	PrintNumber(result);
	return 0;
}
```
1. _매개변수를 넣어주는 실습_
	- `push` 가 2번 일어나고 변수를 스택에 오른쪽에서 왼쪽 순서로 밀어 넣는다 
	- 스택 포인터 관련 정보는 ESP에 저장되어있다 (스택에서 현재 커서가 위치한 곳)
	-  esp 레지스터가 저 _위치_ 를 가리키고 있다는 건 저 위치까지 스택을 유효 범위로 사용하고 있고 나머지 윗부분은 아직 깨끗이 아무는 사용하고 있지 않다는 것을 의미한다 (push 를 하면 윗부분에 저장)
	  ![[StackTest1.png]] ![[StackTest2.png]] ![[StackTest2_1.png]]
	- 어셈블리어에서 call 과 jump 명령어 차이는 call 은 리턴 주소를 넣어준다 ![[StackTest3.png]]
2. _반환 주소 값을 넣어주는 실습_  -> `call MultiflyBy`
	- 00acf068은 이전 함수(main)에서 쓰던 EBP 주소
	- ESP는 계속 변경되는 주소기 때문에 이것을 기준으로 상대 주소를 구하기엔 어려움이 있다. 그래서 EBP에 값(첫 출발점 ESP값)을 넣어두면 고정이 되기 때문에 상대적으로 주소값 계산이 쉬워진다![[StackTest4.png|700]]
3. _지역 변수 값을 넣어주는 실습_ 
	- 매개변수 5와 3이 저장되고, 반환 주소값, EBP, 그 다음 한 주소 건너 뛰고 다음 주소값에 c의 값이 저장되었다
	- 건너뛰는건 컴파일러 마음이지만 제일 낮은 주소값을 가진다는 것은 동일하다
	- 여기서 새로운 함수를 호출하면 방금 할당한 윗부분부터 다시 할당된다![[StackTest5.png]]

***

## 전역변수 vs 지역변수
- 전역변수는 어느 곳에서 접근하여 사용할 수 있는 변수를 의미하며, 메모리의 데이터 영역의 초기와 여부나 const 등에 따라 `.rodata .data .bss` 에 나뉘어 들어간다
- #지역변수 스택의 함수 범위에서만 사용 가능한 변수를 의미하며 수정은 소유하는 함수 내에서만 가능해서 자유도가 낮아서 관리가 쉽다 (전역변수는 최대한 지양)
- (스택 프레임 사진 기억하기)
	- 지역 변수의 값을 함수의 매개변수로 전달해 주면 둘은 서로 다른 주소값을 할당받은 다른 변수이다.
	- 즉, 둘의 저장 위치가 다르기 때문에 값 변화가 없다 -> "**값**"의 전달 (*복사*본에 원래 있던 값을 넣어주는 형식)
```cpp
void IncreaseHp(int hp)
{
	int finalHp = hp + 1;
}
// [매개변수][RET][지역변수(hp=1)] | [매개변수(hp=1)][RET][지역변수(finalHp=2)]
// 매개 변수와 리턴 주소는 이전 함수에서 넣어서 토스해주는 개념, 지역변수는 온전히 자신이 제어
// 함수 호출이 끝나면 3종 세트를 날리면서 원래 있던 곳으로 돌아간다
int main()
{
	int hp = 1;
	cout << "increase 호출 전 : " << hp <endl;   // 1
	IncreaseHp(hp);
	cout << "increase 호출 후 : " << hp <endl;   // 1
	return 0;
}
```

***

## 호출 스택
- #호출스택 은 함수에서 다른 함수를 호출하는 개념
- 함수에서 함수를 호출할 경우 `식별자를 찾을 수 없습니다`는 오류가 뜰 수 있다 ➡️ 이건 컴파일러가 위에서 순서대로 함수를 호출해 내려오기 때문에 밑에 있는 함수를 호출할 수 없어서 발생하는 에러이다
- 매번 프로젝트에서 수동으로 함수 순서를 맞춰줘야 하는가...?
	- `Func1`이 `Func2`를 궁금해 하는 이유는 어셈블리어에서 `call`을 통해 func2의 위치로 이동해서 이어서 실행할 수 있기 때문이다
	- 위에 미리 함수를 선언해줘서 <mark style="background: #824CB496;">우선적으로 해당 함수가 어디 있다는 사실만 알려줘서</mark> 어디로 점프를 해야 하는지 위치를 알려주는 정도로 합의를 한다
	- 즉, `void Func1();` `void Func2();` 함수 `선언부`와 `정의부`가 따로 위치시켜준다
- *visual studio 오른쪽 아래의 호출 스택을 보면 함수까지 어디서 거슬러 왔는지  알 수 있다*
