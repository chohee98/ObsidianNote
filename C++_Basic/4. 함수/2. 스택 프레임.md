> C++은 우리가 직접 메모리를 조작할 수 있기 때문에 스택 영역을 엉뚱한 값으로 조작 했다고 하면 리턴하다 크래시가 날 수 있으니 항상 주의!

## 스택 프레임 😡
- #스택프레임 
- 스택 프레임에는 코드 영역. 데이터 영역, 힙 영역, 스택 영역 존재
- 다 같은 메모리인데 우리가 어떤 용도로 사용할 것인가 세분화해서 건네 받음
- 스택은 높은 메모리 주소에서 낮은 메모리 주소로 증가
- 스택 메모리가 실질적으로 새로 할당 받는 방식이 아닌 프로그램이 실행될 때 이미 정해져 있는 운영체제가 우리에게 얼마 만큼의 스택을 활용할 수 있다는 것을 정해줌. 이걸 함수들끼리 쪼개서 '난 여기까지 사용할꺼야' 하고 남은 영역을 넘겨줌. (함수들끼리 사용하는 메모장)
- 반환 주소 값을 넣어주는 이유는 함수 호출이 완료되었을 때 어디로 돌아와야 하는지 기입

	![[stackflame.png|330]]  	![[StackFlame1.png|300]]

### 실습으로 확인해보기..
```cpp
void PrintNumber(int num)
{
	cout << "result: " << num << endl;
}

int MultiflyBy(int a, int b)
{
	int c = a * b;
	return c;
}

int main()
{
	int a = 3;
	int b = 5;
	int result = MultiflyBy(b, a);

	PrintNumber(result);
	return 0;
}
```

- x86 32비트로 놓고 확인해보기
- _push_ 가 2번 일어나고 변수를 스택에 오른쪽에서 왼쪽 순서로 밀어 넣음
- ![[StackTest1.png]]

- 스택 포인터 관련 정보는 ESP (현재 스택 포인터는 어디까지 사용했는가)
-  esp 레지스터가 저 _위치_ 를 가리키고 있다는 건 저 위치까지 스택을 유효 범위로 사용하고 있고 나머지 윗부분은 아직 깨끗이 아무는 사용하고 있지 않다는 것을 의미 (push 를 하면 윗부분에 저장)
- 어셈블리어에서 call 과 jump 명령어 차이는 call 은 리턴 주소를 넣어줌 
- 어셈블리어를 디버깅 할 때는 f11 f12 이용 
- ![[StackTest2.png]]
- ![[Pasted image 20240116090602.png]]
- _매개변수를 넣어주는 실습_ ![[StackTest3.png]]
-   _반환 주소 값을 넣어주는 실습_  ![[StackTest4.png|700]]
- _지역 변수 값을 넣어주는 실습_ (여기서 새로운 함수를 호출하면 방금 할당한 윗부분부터 다시 할당) ![[StackTest5.png]]

***

## 지역변수, 전역변수
- #전역변수 는 초기와 여부나 const 등에 따라 .rodata  .data  .bss 에 들어가기도 함
- #지역변수 수정은 소유하는 함수 내에서만 가능해서 자유도가 낮음
- 스택 프레임 모습?(사진?) 기억하기

```cpp
void IncreaseHp(int hp)
{
	int finalHp = hp + 1;
}
int main()
{
	int hp = 1;
	cout << "increase 호출 전 : " << hp <endl;   // 1
	IncreaseHp(hp);
	cout << "increase 호출 후 : " << hp <endl;   // 1
	return 0;
}

```
- 매개변수 / RET / 지역변수(hp=1)   |   매개변수(hp=1) / RET / 지역변수
- 매개 변수와 리턴 주소와 같은 경우는 이전 함수에서 넣어서 토스해주는 개념
- 지역 변수의 값을 함수의 매개변수로 전달해 주면 둘의 저장 위치가 다르기 때문에 값 변화가 없다
- "**값**"의 전달 (복사본에 원래 있던 값을 넣어주는 형식)

***

## 호출 스택
- #호출스택
- 함수에서 함수를 호출할 경우 '식별자를 찾을 수 없습니다'는 오류가 뜰 수 있음. 이건 컴파일러가 위에서부터 순서대로 함수를 호출해 내려오기 때문에 밑에 있는 함수를 호출할 수 없음
- 매번 함수를 호출할 때마다 순서를 맞춰줘야 하는가? (float)a
- 위에 미리 함수를 선언해주기 `void Func1();` `void Func2();` 함수 선언부와 정의부가 따로 있음
- _visual studio 오른쪽 아래의 호출 스택을 보면 함수까지 어디서 거슬러 왔는지  알 수 있음_
