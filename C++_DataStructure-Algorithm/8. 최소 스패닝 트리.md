## Disjoint Set
```cpp
// ê·¸ë˜í”„/íŠ¸ë¦¬ ì‘ìš©

// ìƒí˜¸ ë°°íƒ€ì  ì§‘í•© (Disjoint Set)
// -> ìœ ë‹ˆì˜¨-íŒŒì¸ë“œ Union-Find (í•©ì¹˜ê¸°-ì°¾ê¸°)

// Lineage Battleground (í˜¼ì¢…!)
// í˜ˆë§¹ì „ + ì„œë°”ì´ë²Œ
// 1ì¸ íŒ€ 1000ëª… ì…ì¥ (íŒ€id 0~999)
// ë™ë§¹ (1ë²ˆíŒ€ + 2ë²ˆíŒ€ = 1ë²ˆíŒ€ ë³‘í•©)

void LineageBattleground()
{
	struct User
	{
		int teamId;
	};

	// TODO : UserManager (ìœ ì €ë¥¼ ë§Œë“¤ì–´ì¤Œ)
	vector<User> users;
	for (int i = 0; i < 1000; i++)
	{
		users.push_back(User{ i });
	}

	// íŒ€ ë™ë§¹
	// users[1] <-> users[5] ë™ë§¹ (íŒ€ ì•„ë˜ë¡œ ë“¤ì–´ê°€ê²Œë”)
	users[5].teamId = users[1].teamId; // 1ë²ˆíŒ€ìœ¼ë¡œ ë°”ê¿”ì¹˜ê¸°

	// 1:1ë¡œ í•©ë³‘í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ë‹¤ìˆ˜ì˜ ì‚¬ëŒì´ íŒ€ ì´ë™ì„ í•˜ê²Œ ë˜ë©´
	// teamid=1ì¸ íŒ€ê³¼teamid=2ì¸ íŒ€ì´ í†µí•©
	for (User& user : users)
	{
		if (user.teamId == 1)
			user.teamId = 2;
	}

	// ì°¾ê¸° ì—°ì‚° O(1)
	// í•©ì¹˜ê¸° ì—°ì‚° O(N)
}

// íŠ¸ë¦¬ êµ¬ì¡°ë¥¼ ì´ìš©í•œ ìƒí˜¸ ë°°íƒ€ì  ì§‘í•©ì˜ í‘œí˜„
// [0] [1] [2] [3] [4]
struct Node
{
	Node* leader;
};

// ì¡°ì§ í­ë ¥ë°° êµ¬ì¡°?
// [1]		[3]
// [2]	 [4][5]
//			[0]
// ì‹œê°„ ë³µì¡ë„ : íŠ¸ë¦¬ì˜ ë†’ì´ì— ë¹„ë¡€í•œ ì‹œê°„ì´ ê±¸ë¦¼
class NaiveDisjointSet
{
public:
	NaiveDisjointSet(int n) : _parent(n)
	{
		for (int i = 0; i < n; i++)
			_parent[i] = i;
	}

	// ë‹ˆ ëŒ€ì¥ì´ ëˆ„êµ¬ë‹ˆ?
	int Find(int u)
	{
		if (u == _parent[u]) // ë‚´ê°€ ìµœìƒìœ„ ë…¸ë“œì¼ ê²½ìš°
			return u;

		return Find(_parent[u]); // ë£¨íŠ¸ ë…¸ë“œê¹Œì§€ íƒ€ê³  ì˜¬ë¼ê°€ê²Œë”
	}

	// uì™€ vë¥¼ í•©ì¹œë‹¤ (ì¼ë‹¨ uê°€ v ë°‘ìœ¼ë¡œ)
	void Merge(int u, int v)
	{
		u = Find(u);
		v = Find(v);

		if (u == v)		// ë‘˜ì´ ì†í•´ìˆëŠ” ê·¸ë£¹ì´ ê°™ì„ ê²½ìš°
			return;

		_parent[u] = v;
	}

private:
	vector<int> _parent; // ëª‡ë²ˆ ì¸ë±ìŠ¤ ë¶€ëª¨ëŠ” ëˆ„êµ¬ì¸ê°€
};

// íŠ¸ë¦¬ê°€ í•œìª½ìœ¼ë¡œ ê¸°ìš°ëŠ” ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ì„ ?
// íŠ¸ë¦¬ë¥¼ í•©ì¹  ë•Œ, í•­ìƒ [ë†’ì´ê°€ ë‚®ì€ íŠ¸ë¦¬ë¥¼] [ë†’ì´ê°€ ë†’ì€ íŠ¸ë¦¬] ë°‘ìœ¼ë¡œ
// (Union-By-Rank) ë­í¬ì— ì˜í•œ í•©ì¹˜ê¸° ìµœì í™”
// ì‹œê°„ ë³µì¡ë„ O(Ackermann(n)) = O(1)
class DisjointSet
{
public:
	DisjointSet(int n) : _parent(n), _rank(n, 1)
	{
		for (int i = 0; i < n; i++)
			_parent[i] = i;
	}

	// ì¡°ì§ í­ë ¥ë°° êµ¬ì¡°?
	// [1]		[3]
	// [2]	 [4][5]
	// 		    [0]

	// ë‹ˆ ëŒ€ì¥ì´ ëˆ„êµ¬ë‹ˆ?
	int Find(int u)
	{
		if (u == _parent[u])
			return u;

		//return Find(_parent[u]);
		// ë§¤ë²ˆ ë¶€ëª¨ë¥¼ ì°¾ëŠ”ê±´ ë¶€ë‹´ë˜ë‹ˆê¹Œ ì €ì¥í•´ë‘ë©´ ë¹ ë¥´ê²Œ ë™ì‘ ê°€ëŠ¥(ìµœì í™”)
		return _parent[u] = Find(_parent[u]);
	}

	// uì™€ vë¥¼ í•©ì¹œë‹¤
	void Merge(int u, int v)
	{
		u = Find(u);
		v = Find(v);

		if (u == v)
			return;

		// íŠ¸ë¦¬ ë†’ì´ ë¹„êµ
		if (_rank[u] > _rank[v])
			swap(u, v);

		// rank[u] <= rank[v] ë³´ì¥ë¨
		_parent[u] = v;

		// [1]		[3]
		// [2]	 [4][5][1]
		// [6]		[0][2]
		//			   [6]
		if (_rank[u] == _rank[v])
			_rank[v]++;
	}

private:
	vector<int> _parent;
	vector<int> _rank;		// ë†’ì´ ì¶”ì 
};

int main()
{
	DisjointSet teams(1000);

	teams.Merge(10, 1);
	int teamId = teams.Find(1);
	int teamId2 = teams.Find(10);

	teams.Merge(3, 2);
	int teamId3 = teams.Find(3);
	int teamId4 = teams.Find(2);

	teams.Merge(1, 3);
	int teamId6 = teams.Find(1);
	int teamId7 = teams.Find(3);
}
```

***

## MST (Minimum Spanning Tree)
- ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬)
- ì‚¬ì´í´ì´ ìƒê¸°ë©´ ì•ˆë˜ë©°, ëª¨ë“  ê²½ë¡œë“¤ì— ëŒ€í•´ì„œ ëª¨ë“  ì •ì ë“¤ì´ ì—°ê²°ì´ ë˜ì–´ìˆì–´ì•¼ í•œë‹¤

### í¬ë£¨ìŠ¤ì¹¼(KRUSKAL) MST ì•Œê³ ë¦¬ì¦˜
- íƒìš•ì ì¸(greedy) ë°©ë²•ì„ ì´ìš©
- ì§€ê¸ˆ ì´ ìˆœê°„ì— ìµœì ì¸ ë‹µì„ ì„ íƒí•˜ì—¬ ê²°ê³¼ë¥¼ ë„ì¶œí•˜ì 
	- ì‘ì€ ì• ë“¤ë¼ë¦¬ ë¨¼ì € ì—°ê²°í•˜ë˜ ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•ŠëŠ”ì§€ ê³„ì† ì²´í¬í•´ê°€ë©´ì„œ ê¸¸ì„ ë§Œë“¤ì–´ì•¼ í•œë‹¤
	- ì‚¬ì´í´ì´ ìƒê¸°ì§€ ì•Šê²Œ í•˜ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œ? -> ì„œë¡œ ì—°ê²°ë˜ì–´ ìˆëŠ” ì• ë“¤ë¼ë¦¬ ê·¸ë£¹ì„ ë§Œë“¤ê³  ê°™ì€ ê·¸ë£¹ ë‚´ì— ìˆëŠ” ì• ë“¤ë¼ë¦¬ ê°„ì„  ì—°ê²°ì„ í•˜ì§€ ëª»í•˜ê²Œ í•˜ë©° ì—°ê²°ëœ ì• ë“¤ë¼ë¦¬ëŠ” í•˜ë‚˜ì˜ ê·¸ë£¹ìœ¼ë¡œ ê³„ì† í•©ì³ì¤€ë‹¤ â¡ï¸ ìƒí˜¸ ë°°íƒ€ì  ì§‘í•© (Disjoint Set) ì´ìš©í•˜ê¸°!!

```cpp
class DisjointSet
{
public:
	DisjointSet(int n) : _parent(n), _rank(n, 1)
	{
		for (int i = 0; i < n; i++)
			_parent[i] = i;
	}

	int Find(int u)
	{
		if (u == _parent[u])
			return u;

		return _parent[u] = Find(_parent[u]);
	}

	void Merge(int u, int v)
	{
		u = Find(u);
		v = Find(v);

		if (u == v)
			return;
		if (_rank[u] > _rank[v])
			swap(u, v);

		_parent[u] = v;

		if (_rank[u] == _rank[v])
			_rank[v]++;
	}

private:
	vector<int> _parent;
	vector<int> _rank;		// ë†’ì´ ì¶”ì 
};

struct Vertex
{
	// int data;
};

vector<Vertex> vertices;
vector<vector<int>> adjacent;	// ì¸ì ‘ í–‰ë ¬

void CreateGraph()
{
	vertices.resize(6);
	adjacent = vector<vector<int>>(6, vector<int>(6, -1));

	adjacent[0][1] = adjacent[1][0] = 15;
	adjacent[0][3] = adjacent[3][0] = 35;
	adjacent[1][2] = adjacent[2][1] = 5;
	adjacent[1][3] = adjacent[3][1] = 10;
	adjacent[3][4] = adjacent[4][3] = 5;
	adjacent[3][5] = adjacent[5][3] = 10;
	adjacent[5][4] = adjacent[4][5] = 5;
}

struct CostEdge
{
	int cost;
	int u;		// ì •ì 
	int v;		// ì •ì 

	bool operator<(CostEdge& other)
	{
		return cost < other.cost;
	}
};

int Kruskal(vector<CostEdge>& selected)
{
	int ret = 0;
	selected.clear();

	vector<CostEdge> edges;

	// adjacentì˜ ëª¨ë“  ê°„ì„ ë“¤ì„ cost ìˆœì„œëŒ€ë¡œ ì •ë ¬
	for (int u = 0; u < adjacent.size(); u++)
	{
		for (int v = 0; v < adjacent[u].size(); v++)
		{
			// ì•ì—ì„œ ê°„ì„ ì„ ì–‘ìª½ìœ¼ë¡œ ì €ì¥í–ˆê¸° ë•Œë¬¸ì— ê°™ì€ ê°„ì„ ì´ ë‘ë²ˆ ì¶”ê°€ë˜ì§€ ì•Šê²Œ í•˜ê¸°
			if (u > v)
				continue;

			int cost = adjacent[u][v];
			if (cost == -1)
				continue;

			edges.push_back(CostEdge{ cost, u, v });
		}
	}

	std::sort(edges.begin(), edges.end());

	DisjointSet sets(vertices.size());

	for (CostEdge& edge : edges)
	{
		// ê°™ì€ ê·¸ë£¹ì´ë©´ ìŠ¤í‚µ (ì•ˆ ê·¸ëŸ¬ë©´ ì‚¬ì´í´ ë°œìƒ)
		if (sets.Find(edge.u) == sets.Find(edge.v))
			continue;

		// ë‘ ê·¸ë£¹ì„ í•©ì¹œë‹¤
		sets.Merge(edge.u, edge.v);
		selected.push_back(edge);  // ê°„ì„  ì¶”ê°€
		ret += edge.cost;
	}

	return ret;
}

int main()
{
	CreateGraph();

	vector<CostEdge> selected;
	int cost = Kruskal(selected);

	return 0;
}
```

![[8-1. MST1.png|400]] ![[8-2. MST2.png]]


### Maze
- ë§¨ ì•„ë˜ì™€ ìœ—ì¤„ì´ 100% í™•ë¥ ë¡œ ì¼ìë¡œ ë§Œë“¤ì–´ì§€ëŠ” ë¶€ë¶„ ìˆ˜ì •í•´ë³´ì! (í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ ì´ìš©) ![[8-3. MSTMazeBefore.png|300]]
- ë°”ì´ë„ˆë¦¬ íŠ¸ë¦¬ ì•Œê³ ë¦¬ì¦˜ì—ì„œëŠ” ì´ˆë¡ìƒ‰ ë¶€ë¶„ì—ì„œ ìš°ì¸¡ í˜¹ì€ ì•„ë˜ 1/2 í™•ë¥ ë¡œ ê³„ì† ì˜¬ë¼ê°€ë©´ì„œ ê¸¸ì„ ëš«ì–´ì£¼ëŠ” í˜•ì‹ìœ¼ë¡œ ë§Œë“  ë°˜ë©´, í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì—ì„œëŠ” ì´ˆë¡ìƒ‰ ì ì´ ì •ì ì´ë¼ê³  ìƒê°í•´ ë³´ë©´ ê°ˆ ìˆ˜ ìˆëŠ” ëª¨ë“  í›„ë³´ë¥¼ ê°„ì„ ì´ë¼ê³  í•  ë•Œ ëª¨ë“  ê°„ì„ ì— ëŒ€í•´ ëœë¤ìœ¼ë¡œ costë¥¼ ë¶€ì—¬í•˜ì—¬ í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì„ ì ìš©í•´ ë³´ë©´ ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ê°€ ë§Œë“¤ì–´ì§€ë©´ì„œ cost í•©ì´ ìµœì†Œê°€ ë˜ëŠ” í˜•ì‹ìœ¼ë¡œ ê¸¸ì´ ëš«ë¦¬ê²Œ ëœë‹¤
  ![[8-4. MSTMazeBefore2.png|300]]

#### DisjointSet.h
```cpp
#pragma once
class DisjointSet
{
public:
	DisjointSet(int n) : _parent(n), _rank(n, 1)
	{
		for (int i = 0; i < n; i++)
			_parent[i] = i;
	}

	int Find(int u)
	{
		if (u == _parent[u])
			return u;

		return _parent[u] = Find(_parent[u]);
	}

	void Merge(int u, int v)
	{
		u = Find(u);
		v = Find(v);

		if (u == v)
			return;
		if (_rank[u] > _rank[v])
			swap(u, v);

		_parent[u] = v;

		if (_rank[u] == _rank[v])
			_rank[v]++;
	}

private:
	vector<int> _parent;
	vector<int> _rank;		// ë†’ì´ ì¶”ì 
};
```

#### Board.h
```cpp
#pragma once
#include "ConsoleHelper.h"

class Player;

enum
{
	BOARD_MAX_SIZE = 100
};

enum class TileType
{
	NONE = 0,
	EMPTY,
	WALL,
};

struct CostEdge
{
	int cost;
	Pos u;
	Pos v;

	bool operator<(CostEdge& other)
	{
		return cost < other.cost;
	}
};

class Board
{
public:
	Board();
	~Board();

	void			Init(int32 size, Player* player);
	void			Render();

	void			GenerateMap();
	TileType		GetTileType(Pos pos);
	ConsoleColor	GetTileColor(Pos pos);

	Pos				GetEnterPos() { return Pos{ 1, 1 }; }
	Pos				GetExitPos() { return Pos{ _size - 2, _size - 2 }; }
	int32			GetSize() { return _size; }

private:
	TileType		_tile[BOARD_MAX_SIZE][BOARD_MAX_SIZE] = {};
	int32			_size = 0;
	Player*			_player = nullptr;
};
```

#### Board.cpp
```cpp
#include "pch.h"
#include "Board.h"
#include "ConsoleHelper.h"
#include "Player.h"
#include "DisjointSet.h"

const char* TILE = "â– ";

Board::Board()
{

}

Board::~Board()
{

}

void Board::Init(int32 size, Player* player)
{
	_size = size;
	_player = player;

	GenerateMap();
}

void Board::Render()
{
	ConsoleHelper::SetCursorPosition(0, 0);
	ConsoleHelper::ShowConsoleCursor(false);

	for (int32 y = 0; y < 25; y++)
	{
		for (int32 x = 0; x < 25; x++)
		{
			ConsoleColor color = GetTileColor(Pos{ y, x });
			ConsoleHelper::SetCursorColor(color);
			cout << TILE;
		}

		cout << endl;
	}
}

// Binary Tree ë¯¸ë¡œ ìƒì„± ì•Œê³ ë¦¬ì¦˜
// - Mazes For Programmers
void Board::GenerateMap()
{
	for (int32 y = 0; y < _size; y++)
	{
		for (int32 x = 0; x < _size; x++)
		{
			if (x % 2 == 0 || y % 2 == 0)
				_tile[y][x] = TileType::WALL;
			else
				_tile[y][x] = TileType::EMPTY;
		}
	}

	// ëœë¤ìœ¼ë¡œ ìš°ì¸¡ í˜¹ì€ ì•„ë˜ë¡œ ê¸¸ì„ ëš«ëŠ” ì‘ì—… ì§€ì›€
	// MST ì ìš© ğŸ”¥
	vector<CostEdge> edges;
	
	// edges í›„ë³´ë¥¼ ëœë¤ costë¡œ ë“±ë¡í•œë‹¤
	for (int32 y = 0; y < _size; y++)
	{
		for (int32 x = 0; x < _size; x++)
		{
			if (x % 2 == 0 || y % 2 == 0)  // ë²½
				continue;

			// ìš°ì¸¡ ì—°ê²°í•˜ëŠ” ê°„ì„  í›„ë³´
			if (x < _size - 2)
			{
				const int32 randValue = ::rand() % 100;
				edges.push_back(CostEdge{ randValue, Pos{y, x}, Pos{y, x + 2 } });
			}

			// ì•„ë˜ë¡œ ì—°ê²°í•˜ëŠ” ê°„ì„  í›„ë³´
			if (y < _size - 2)
			{
				const int32 randValue = ::rand() % 100;
				edges.push_back(CostEdge{ randValue, Pos{y, x}, Pos{y + 2, x} });
			}
		}
	}

	// cost ì‘ì€ ìˆœì„œëŒ€ë¡œ ì •ë ¬
	std::sort(edges.begin(), edges.end());

	DisjointSet sets(_size * _size);

	// ìˆœíšŒ
	for (CostEdge& edge : edges)
	{
		// 2ì°¨ì› ë°°ì—´ì„ 1ì°¨ì›ìœ¼ë¡œ ê´€ë¦¬í•˜ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©í•˜ëŠ” ê³µì‹
		int u = edge.u.y * _size + edge.u.x;
		int v = edge.v.y * _size + edge.v.x;
		// ê°™ì€ ê·¸ë£¹ì´ë©´ ìŠ¤í‚µ (ì•ˆ ê·¸ëŸ¬ë©´ ì‚¬ì´í´ ë°œìƒ)
		if (sets.Find(u) == sets.Find(v))
			continue;

		// ë‘ ê·¸ë£¹ì„ í•©ì¹œë‹¤
		sets.Merge(u, v);

		// ë§µì— ì ìš© (ê¸¸ ëš«ì–´ì£¼ê¸°)
		int y = (edge.u.y + edge.v.y) / 2;
		int x = (edge.u.x + edge.v.x) / 2;
		_tile[y][x] = TileType::EMPTY;
	}
}

TileType Board::GetTileType(Pos pos)
{
	if (pos.x < 0 || pos.x >= _size)
		return TileType::NONE;

	if (pos.y < 0 || pos.y >= _size)
		return TileType::NONE;

	return _tile[pos.y][pos.x];
}

ConsoleColor Board::GetTileColor(Pos pos)
{
	if (_player && _player->GetPos() == pos)
		return ConsoleColor::YELLOW;

	if (GetExitPos() == pos)
		return ConsoleColor::BLUE;

	TileType tileType = GetTileType(pos);

	switch (tileType)
	{
	case TileType::EMPTY:
		return ConsoleColor::GREEN;
	case TileType::WALL:
		return ConsoleColor::RED;
	}

	return ConsoleColor::WHITE;
}

```
![[8-5. MSTMazeAfter.png|400]]

### í”„ë¦¼(PRIM) MST ì•Œê³ ë¦¬ì¦˜
- í•˜ë‚˜ì˜ ì‹œì‘ì ìœ¼ë¡œ êµ¬ì„±ëœ íŠ¸ë¦¬ì— ê°„ì„ ì„ í•˜ë‚˜ì”© ìˆ˜ì§‘í•˜ë©° ì§„í–‰í•œë‹¤
- ë‹¤ìµìŠ¤íŠ¸ë¼ëŠ” ì‹œì‘ì ì„ ê¸°ì¤€ìœ¼ë¡œ ìµœë‹¨ costë¥¼ ì°¾ëŠ” ë°˜ë©´, í”„ë¦¼ì€ íŠ¸ë¦¬(ì •ì  ì§‘í•©)ì„ ê¸°ì¤€ìœ¼ë¡œ ìµœë‹¨ costë¥¼ ì°¾ëŠ”ë‹¤

#### Board.h
```cpp
#pragma once
#include "ConsoleHelper.h"

class Player;

enum
{
	BOARD_MAX_SIZE = 100
};

enum class TileType
{
	NONE = 0,
	EMPTY,
	WALL,
};



class Board
{
public:
	Board();
	~Board();

	void			Init(int32 size, Player* player);
	void			Render();

	void			GenerateMap_Kruskal();
	void			GenerateMap_Prim();

	TileType		GetTileType(Pos pos);
	ConsoleColor	GetTileColor(Pos pos);

	Pos				GetEnterPos() { return Pos{ 1, 1 }; }
	Pos				GetExitPos() { return Pos{ _size - 2, _size - 2 }; }
	int32			GetSize() { return _size; }

private:
	TileType		_tile[BOARD_MAX_SIZE][BOARD_MAX_SIZE] = {};
	int32			_size = 0;
	Player*			_player = nullptr;
};
```

#### Board.cpp
```cpp
#include "pch.h"
#include "Board.h"
#include "ConsoleHelper.h"
#include "Player.h"
#include "DisjointSet.h"

const char* TILE = "â– ";

Board::Board()
{

}

Board::~Board()
{

}

void Board::Init(int32 size, Player* player)
{
	_size = size;
	_player = player;

	//GenerateMap_Kruskal();
	GenerateMap_Prim();
}

void Board::Render()
{
	ConsoleHelper::SetCursorPosition(0, 0);
	ConsoleHelper::ShowConsoleCursor(false);

	for (int32 y = 0; y < 25; y++)
	{
		for (int32 x = 0; x < 25; x++)
		{
			ConsoleColor color = GetTileColor(Pos{ y, x });
			ConsoleHelper::SetCursorColor(color);
			cout << TILE;
		}

		cout << endl;
	}
}

// Binary Tree ë¯¸ë¡œ ìƒì„± ì•Œê³ ë¦¬ì¦˜
// - Mazes For Programmers
void Board::GenerateMap_Kruskal()
{
	struct CostEdge
	{
		int cost;
		Pos u;
		Pos v;

		bool operator<(CostEdge& other)
		{
			return cost < other.cost;
		}
	};

	for (int32 y = 0; y < _size; y++)
	{
		for (int32 x = 0; x < _size; x++)
		{
			if (x % 2 == 0 || y % 2 == 0)
				_tile[y][x] = TileType::WALL;
			else
				_tile[y][x] = TileType::EMPTY;
		}
	}

	// ëœë¤ìœ¼ë¡œ ìš°ì¸¡ í˜¹ì€ ì•„ë˜ë¡œ ê¸¸ì„ ëš«ëŠ” ì‘ì—… ì§€ì›€

	vector<CostEdge> edges;
	
	// edges í›„ë³´ë¥¼ ëœë¤ costë¡œ ë“±ë¡í•œë‹¤
	for (int32 y = 0; y < _size; y++)
	{
		for (int32 x = 0; x < _size; x++)
		{
			if (x % 2 == 0 || y % 2 == 0)  // ë²½
				continue;

			// ìš°ì¸¡ ì—°ê²°í•˜ëŠ” ê°„ì„  í›„ë³´
			if (x < _size - 2)
			{
				const int32 randValue = ::rand() % 100;
				edges.push_back(CostEdge{ randValue, Pos{y, x}, Pos{y, x + 2 } });
			}

			// ì•„ë˜ë¡œ ì—°ê²°í•˜ëŠ” ê°„ì„  í›„ë³´
			if (y < _size - 2)
			{
				const int32 randValue = ::rand() % 100;
				edges.push_back(CostEdge{ randValue, Pos{y, x}, Pos{y + 2, x} });
			}
		}
	}

	// cost ì‘ì€ ìˆœì„œëŒ€ë¡œ ì •ë ¬
	std::sort(edges.begin(), edges.end());

	DisjointSet sets(_size * _size);

	// ìˆœíšŒ
	for (CostEdge& edge : edges)
	{
		// 2ì°¨ì› ë°°ì—´ì„ 1ì°¨ì›ìœ¼ë¡œ ê´€ë¦¬í•˜ê³  ì‹¶ì„ ë•Œ ì‚¬ìš©í•˜ëŠ” ê³µì‹
		int u = edge.u.y * _size + edge.u.x;
		int v = edge.v.y * _size + edge.v.x;
		// ê°™ì€ ê·¸ë£¹ì´ë©´ ìŠ¤í‚µ (ì•ˆ ê·¸ëŸ¬ë©´ ì‚¬ì´í´ ë°œìƒ)
		if (sets.Find(u) == sets.Find(v))
			continue;

		// ë‘ ê·¸ë£¹ì„ í•©ì¹œë‹¤
		sets.Merge(u, v);

		// ë§µì— ì ìš© (ê¸¸ ëš«ì–´ì£¼ê¸°)
		int y = (edge.u.y + edge.v.y) / 2;
		int x = (edge.u.x + edge.v.x) / 2;
		_tile[y][x] = TileType::EMPTY;
	}
}

void Board::GenerateMap_Prim()
{
	struct CostEdge
	{
		int cost;
		Pos vtx;

		bool operator<(const CostEdge& other) const
		{
			return cost < other.cost;
		}
	};

	for (int32 y = 0; y < _size; y++)
	{
		for (int32 x = 0; x < _size; x++)
		{
			if (x % 2 == 0 || y % 2 == 0)
				_tile[y][x] = TileType::WALL;
			else
				_tile[y][x] = TileType::EMPTY;
		}
	}

	// edges[u] : u ì •ì ê³¼ ì—°ê²°ëœ ê°„ì„  ëª©ë¡ ë§Œë“¤ì–´ì£¼ê¸°
	map<Pos, vector<CostEdge>> edges;

	// edges í›„ë³´ë¥¼ ëœë¤ìœ¼ë¡œ ë“±ë¡í•œë‹¤
	for (int32 y = 0; y < _size; y++)
	{
		for (int32 x = 0; x < _size; x++)
		{
			if (x % 2 == 0 || y % 2 == 0)
				continue;

			// ìš°ì¸¡ ì—°ê²°í•˜ëŠ” ê°„ì„  í›„ë³´
			if (x < _size - 2)
			{
				const int32 randValue = ::rand() % 100;
				Pos u = Pos{ y, x };
				Pos v = Pos{ y, x + 2 };
				edges[u].push_back(CostEdge{ randValue, v });
				edges[v].push_back(CostEdge{ randValue, u });
			}

			// ì•„ë˜ë¡œ ì—°ê²°í•˜ëŠ” ê°„ì„  í›„ë³´
			if (y < _size - 2)
			{
				const int32 randValue = ::rand() % 100;
				Pos u = Pos{ y, x };
				Pos v = Pos{ y + 2, x };
				edges[u].push_back(CostEdge{ randValue, v });
				edges[v].push_back(CostEdge{ randValue, u });
			}
		}
	}

	// í•´ë‹¹ ì •ì ì´ íŠ¸ë¦¬ì— í¬í•¨ë˜ì–´ ìˆë‚˜?
	map<Pos, bool> added;
	// ì–´ë–¤ ì •ì ì´ ëˆ„êµ¬ì— ì˜í•´ ì—°ê²° ë˜ì—ˆëŠ”ì§€
	map<Pos, Pos> parent;
	// ë§Œë“¤ê³  ìˆëŠ” íŠ¸ë¦¬ì— ì¸ì ‘í•œ ê°„ì„  ì¤‘, í•´ë‹¹ ì •ì ì— ë‹¿ëŠ” ìµœì†Œ ê°„ì„ ì˜ ì •ë³´
	map<Pos, int32> best;

	// ë‹¤ìµìŠ¤íŠ¸ë¼ë‘ ê±°~ì˜ ìœ ì‚¬í•¨. ë‹¨!
	// - ë‹¤ìµìŠ¤íŠ¸ë¼ì—ì„œëŠ” bestê°€ [ì‹œì‘ì ]ì„ ê¸°ì¤€ìœ¼ë¡œ í•œ cost
	// - í”„ë¦¼ì—ì„œëŠ” bestê°€ [í˜„ì¬ íŠ¸ë¦¬]ë¥¼ ê¸°ì¤€ìœ¼ë¡œ í•œ ê°„ì„  cost

	for (int32 y = 0; y < _size; y++)
	{
		for (int32 x = 0; x < _size; x++)
		{
			best[Pos{ y, x }] = INT32_MAX;
			added[Pos{ y, x }] = false;
		}
	}

	priority_queue<CostEdge> pq;
	const Pos startPos = Pos{ 1, 1 }; // ëœë¤ìœ¼ë¡œ ì •í•´ë„ ë¨
	pq.push(CostEdge{ 0, startPos });
	best[startPos] = 0;
	parent[startPos] = startPos;

	while (pq.empty() == false)
	{
		CostEdge bestEdge = pq.top();
		pq.pop();

		// ìƒˆë¡œ ì—°ê²°ëœ ì •ì 
		Pos v = bestEdge.vtx;
		// ì´ë¯¸ ì¶”ê°€ë˜ì—ˆë‹¤ë©´ ìŠ¤í‚µ
		if (added[v])
			continue;

		added[v] = true;

		// ë§µì— ì ìš©
		{
			int y = (parent[v].y + v.y) / 2;
			int x = (parent[v].x + v.x) / 2;
			_tile[y][x] = TileType::EMPTY;
		}

		// ë°©ê¸ˆ ì¶”ê°€í•œ ì •ì ì— ì¸ì ‘í•œ ê°„ì„ ë“¤ì„ ê²€ì‚¬í•œë‹¤
		for (CostEdge& edge : edges[v])
		{
			// ì´ë¯¸ ì¶”ê°€ ë˜ì—ˆìœ¼ë©´ ìŠ¤í‚µ
			if (added[edge.vtx])
				continue;
			// ë‹¤ë¥¸ ê²½ë¡œë¡œ ë” ì¢‹ì€ í›„ë³´ê°€ ë°œê²¬ ë˜ì—ˆìœ¼ë©´ ìŠ¤í‚µ
			if (edge.cost > best[edge.vtx])
				continue;

			// ê°’ì„ ë®ì–´ì“°ê³  ì˜ˆì•½
			best[edge.vtx] = edge.cost;
			parent[edge.vtx] = v;
			pq.push(edge);
		}
	}
}

TileType Board::GetTileType(Pos pos)
{
	if (pos.x < 0 || pos.x >= _size)
		return TileType::NONE;

	if (pos.y < 0 || pos.y >= _size)
		return TileType::NONE;

	return _tile[pos.y][pos.x];
}

ConsoleColor Board::GetTileColor(Pos pos)
{
	if (_player && _player->GetPos() == pos)
		return ConsoleColor::YELLOW;

	if (GetExitPos() == pos)
		return ConsoleColor::BLUE;

	TileType tileType = GetTileType(pos);

	switch (tileType)
	{
	case TileType::EMPTY:
		return ConsoleColor::GREEN;
	case TileType::WALL:
		return ConsoleColor::RED;
	}

	return ConsoleColor::WHITE;
}

```