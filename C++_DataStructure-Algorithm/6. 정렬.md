# ì •ë ¬
```cpp
// 1) ë²„ë¸” ì •ë ¬ (Bubble Sort) -> í° ìˆ˜ë¥¼ í•˜ë‚˜ì”© ë’¤ë¡œ ì˜¬ë ¤ë³´ë‚¸ë‹¤ (íš¨ìœ¨ì´ ë‚®ë‹¤)
void BubbleSort(vector<int>& v)
{
	const int n = (int)v.size();

	// ë“±ì°¨ìˆ˜ì—´ì˜ í•© = N * (N-1) / 2
	// O(N^2)
	for (int i = 0; i < n - 1; i++)
	{
		for (int j = 0; j < (n - 1 - i); j++)
		{
			if (v[j] > v[j + 1])
			{
				int temp = v[j];
				v[j] = v[j + 1];
				v[j + 1] = temp;
			}
		}
	}
}

// 2) ì„ íƒ ì •ë ¬ (Selection Sort) 
// -> ë‘˜ë‘˜ ë¹„êµí•˜ëŠ”ê²Œ ì•„ë‹ˆë¼ ì²˜ìŒì— ëê¹Œì§€ ìŠ¤ìº”í•´ì„œ ê°€ì¥ ì‘ì€ ìˆ«ìë¥¼ ê³ ë¥´ê³  swap
void SelectionSort(vector<int>& v)
{
	const int n = (int)v.size();

	// O(N^2)
	for (int i = 0; i < n - 1; i++)
	{
		int bestIdx = i;

		for (int j = i + 1; j < n; j++)
		{
			if (v[j] < v[bestIdx])
				bestIdx = j;
		}

		// êµí™˜
		int temp = v[i];
		v[i] = v[bestIdx];
		v[bestIdx] = temp;
	}
}

// 3) ì‚½ì… ì •ë ¬ (Insertion Sort)
// -> í›„ë³´êµ° ë°ì´í„°ë¥¼ í•˜ë‚˜ì”© ë½‘ì•„ì„œ ìƒˆë¡œìš´ ì •ë ¬ ë¬¶ìŒì— ìˆœì„œì— ë§ê²Œ ë¼ì›Œë„£ê¸°
void InsertionnSort(vector<int>& v)
{
	const int n = (int)v.size();

	// O(N^2)
	for (int i = 1; i < n; i++)
	{
		int InsertData = v[i];

		int j;
		for (j = i - 1; j >= 0; j--)
		{
			if (v[j] > InsertData)
				v[j + 1] = v[i];
			else
				break;
		}
		v[j + 1] = InsertData;
	}
}

int main()
{
	vector<int> v{ 1, 5, 3, 4, 2 };
	std::sort(v.begin(), v.end());

	//BubbleSort(v);
	//SelectionSort(v);
	InsertionnSort(v);
}
```

***

## í™ ì •ë ¬ê³¼ ë³‘í•© ì •ë ¬
- ë³‘í•© ì •ë ¬ì€ ë¬¸ì œë¥¼ ë¶„í• í•´ì„œ ë‹¤ë¥¸ ì• ë“¤ì´ ì‹¤í–‰ì„ í•˜ê²Œ ë§Œë“¤ì–´ ì¤„ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ë‚˜ì¤‘ì— ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œë„ ìœ ìš©í•´ì§„ë‹¤
- ![[6-1. ë³‘í•©ì •ë ¬.png|500]]

```cpp
// í™ ì •ë ¬
void HeapSort(vector<int>& v)
{
	// ìš°ì„ ìˆœìœ„íìì²´ê°€ í™ êµ¬ì¡°ë¥¼ ì´ìš©í•´ì„œ ë§Œë“¤ì–´ì§
	priority_queue<int, vector<int>, greater<int>> pq; // ì‘ì€ ìˆœì„œëŒ€ë¡œ ë°ì´í„° ë‚˜ì˜´
	
	// O(NlogN)
	for (int num : v)
		pq.push(num);

	v.clear();

	// O(NlogN)
	while (pq.empty() == false)
	{
		v.push_back(pq.top());
		pq.pop();
	}
}

// ë³‘í•© ì •ë ¬
// ë¶„í•  ì •ë³µ (Divide and Conquer)
// ì´ë¯¸ ì–‘ìª½ì´ ë‹¤ ì •ë ¬ì´ ë˜ì–´ ìˆë‹¤ë©´ ë” ì‰½ê²Œ ë³‘í•©í•  ìˆ˜ ìˆë‹¤
// - ë¶„í•  (Divide)		ë¬¸ì œë¥¼ ë” ë‹¨ìˆœí•˜ê²Œ ë¶„í• í•œë‹¤
// - ì •ë³µ (Conquer)		ë¶„í• ëœ ë¬¸ì œë¥¼ í•´ê²°
// - ê²°í•© (Combine)		ê²°ê³¼ë¥¼ ì·¨í•©í•˜ì—¬ ë§ˆë¬´ë¦¬

// [3][K][7][2][J][4][8][9]			8ê°œ * 1
// [3][K][7][2] [J][4][8][9]		4ê°œ * 2
// [3][K] [7][2] [J][4] [8][9]		2ê°œ * 4
// [3] [K] [7] [2] [J] [4] [8] [9]	1ê°œ * 8
// [3][K] [2][7]  [4][J]  [8][9]	2ê°œ * 4 (ì¬ì¡°ë¦½)

// O(NlogN)
void MergeResult(vector<int>& v, int left, int mid, int right)
{
	// [2][3][7][K][4][8][9][J]
	// [l]         [r]
	int leftIdx = left;
	int rightIdx = mid + 1;

	vector<int> temp;

	while (leftIdx <= mid && rightIdx <= right) // ë‘˜ë‘˜ ë¹„êµ
	{
		if (v[leftIdx] <= v[rightIdx])
		{
			temp.push_back(v[leftIdx]);
			leftIdx++;
		}
		else
		{
			temp.push_back(v[rightIdx]);
			rightIdx++;
		}
	}

	// ì™¼ìª½ì´ ë¨¼ì € ëë‚¬ìœ¼ë©´, ì˜¤ë¥¸ìª½ ë‚˜ë¨¸ì§€ ë°ì´í„° ë³µì‚¬
	if (leftIdx > mid)
	{
		while (rightIdx <= right)
		{
			temp.push_back(v[rightIdx]);
			rightIdx++;
		}
	}
	// ì˜¤ë¥¸ìª½ì´ ë¨¼ì € ëë‚¬ìœ¼ë©´, ì™¼ìª½ ë‚˜ë¨¸ì§€ ë°ì´í„° ë³µì‚¬
	else
	{
		while (leftIdx <= mid)
		{
			temp.push_back(v[leftIdx]);
			leftIdx++;
		}
	}

	for (int i = 0; i < temp.size(); i++)
		v[left + i] = temp[i];
}

// ë²¡í„°ì˜ ìë¥´ëŠ” ë²”ìœ„ë¥¼ ì°ì–´ì„œ ë„˜ê²¨ì£¼ê¸°
void MergeSort(vector<int>& v, int left, int right) 
{
	if (left >= right)
		return;

	int mid = (left + right) / 2;		// ì¤‘ê°„
	MergeSort(v, left, mid);			// ì²«ë²ˆì§¸ ì ˆë°˜
	MergeSort(v, mid + 1, right);		// ë‚˜ë¨¸ì§€ ì ˆë°˜

	MergeResult(v, left, mid, right);	// ê²°í•© í•¨ìˆ˜
}

int main()
{
	vector<int> v;

	srand(time(0));

	for (int i = 0; i < 50; i++)
	{
		int randValue = rand() % 100;
		v.push_back(randValue);
	}

	//HeapSort(v);
	MergeSort(v, 0, v.size() - 1);
}
```

#### ë¬¸ì œ
```cpp
// [ë¬¸ì œ] ì •ë ¬ëœ ë²¡í„° a, bê°€ ìˆì„ ë•Œ ë‘ ë°ì´í„°ë¥¼ í•©ì³ì„œ ë¦¬í„´í•˜ëŠ” í•¨ìˆ˜ ë§Œë“¤ê¸°
vector<int> Merge(vector<int> a, vector<int> b)
{
	vector<int> temp;

	int i = 0, j = 0;

	// ë‘ ë²¡í„°ë¥¼ ìˆœíšŒí•˜ë©° ì‘ì€ ìš”ì†Œë¥¼ temp ë²¡í„°ì— ì¶”ê°€
	while (i < a.size() && j < b.size()) {
		if (a[i] < b[j])
		{
			temp.push_back(a[i]);
			++i;
		}
		else
		{
			temp.push_back(b[j]);
			++j;
		}
	}

	// a ë²¡í„°ì˜ ë‚˜ë¨¸ì§€ ìš”ì†Œë¥¼ temp ë²¡í„°ì— ì¶”ê°€
	while (i < a.size())
	{
		temp.push_back(a[i]);
		++i;
	}

	// b ë²¡í„°ì˜ ë‚˜ë¨¸ì§€ ìš”ì†Œë¥¼ temp ë²¡í„°ì— ì¶”ê°€
	while (j < b.size())
	{
		temp.push_back(b[j]);
		++j;
	}

	return temp;
}


int main()
{
	vector<int> v1 = { 1, 3, 5, 7 };
	vector<int> v2 = { 2, 4, 6, 8 };
	vector<int> mergedVec = Merge(v1, v2);
	for (int val : mergedVec) 
	{
		std::cout << val << " ";
	}
}
```

***


## í€µ ì •ë ¬
- 1ë‹¨ê³„) `privot >= arr[low]`ì¼ ë™ì•ˆ `low`ë¥¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™, `privot <= arr[high]`ì¼ ë™ì•ˆ `high`ë¥¼ ì™¼ìª½ìœ¼ë¡œ ì´ë™í•œë‹¤
- 2ë‹¨ê³„) `low < high`ë¼ë©´, `arr[low]`ì™€  `arr[high]` ë°ì´í„° êµì²´í•œë‹¤
- 3ë‹¨ê³„) 1, 2 ë‹¨ê³„ë¥¼ ë°˜ë³µí•˜ë‹¤ê°€ `high <= low` ë©´ ë¹ ì ¸ë‚˜ì˜¤ê³ , `privot`ê³¼ `arr[high]` êµì²´í•œë‹¤
- 4ë‹¨ê³„) ìë¦¬ë¥¼ ì°¾ì€ ìˆ«ìë¥¼ ì œì™¸í•˜ê³ , ë‚˜ë¨¸ì§€ ë¶€ë¶„ì„ ì¬ê·€ì ìœ¼ë¡œ QuickSort!
- ![[6-2. í€™ì •ë ¬.png|500]]

```cpp

// [5][1][3][7][9][2][4][6][8]
// p
//     low                  high	
int Partition(vector<int>& v, int left, int right)
{
	int pivot = v[left];
	int low = left + 1;
	int high = right;

	while (low <= high)
	{
		while (low <= right && pivot >= v[low])
			low++;

		while (high >= left + 1 && pivot <= v[high])
			high--;

		if (low < high)
			swap(v[low], v[high]);
	}
	swap(v[left], v[high]);
	return high;
}

// O(N^2) < ìµœì•…
// O(NlogN) < í‰ê· 
void QuickSort(vector<int>& v, int left, int right)
{
	if (left > right)
		return;

	int pivot = Partition(v, left, right);
	QuickSort(v, left, pivot - 1);
	QuickSort(v, pivot + 1, right);
}

int main()
{
	vector<int> v;

	srand(time(0));

	for (int i = 0; i < 50; i++)
	{
		int randValue = rand() % 100;
		v.push_back(randValue);
	}

	QuickSort(v, 0, v.size() - 1);
}
```


ğŸ“Œ ì‹œê°„ ë³µì¡ë„
```cpp
// PQ O(logN)
// Red-Black Tree O(logN)
// Sorting O(NlogN)
```