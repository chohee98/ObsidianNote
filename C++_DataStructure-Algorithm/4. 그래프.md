# 그래프
- 현실 세계의 사물이나 추상적인 개념 간의 연결 관계를 표현
- 정점(Vertex): 사물이나 개념 등의 데이터를 표현
- 간선(Edge): 정점들을 연결하는데 사용
- 종류: 기본, 가중치 그래프, 방향 그래프
### 그래프 구현해보기
![[4-1. 그래프.png|300]]   >>예시 (기본, 가중치 그래프)
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <stack>
#include <queue>
using namespace std;

void CreateGraph_1()
{
	struct Vertex
	{
		// 간선이 몇개인지 알 수 없기 때문에 vector로 Vertex끼리 서로 가리키게끔 -> 간선 목록
		vector<Vertex*> edges;
		// int data;
	};

	vector<Vertex> v;
	v.resize(6);

	v[0].edges.push_back(&v[1]);
	v[0].edges.push_back(&v[3]);
	v[1].edges.push_back(&v[0]);
	v[1].edges.push_back(&v[2]);
	v[1].edges.push_back(&v[3]);
	v[3].edges.push_back(&v[4]);
	v[5].edges.push_back(&v[4]);

	// Q) 0번 -> 3번 정점이 연결되어 있나요?
	bool connected = false;
	for (Vertex* edge : v[0].edges)
	{
		if (edge == &v[3])
		{
			connected = true;
			break;
		}
	}
}

void CreateGraph_2()
{
	struct Vertex
	{
		// 깔끔하게 정점끼리 연결 관계를 별도의 데이터로 빼서 관리
		// 나중에 실제 데이터와 연결 여부 즉 간선 여부를 분리해서 관리
		// int data;
	};

	vector<Vertex> v;
	v.resize(6);

	// 연결된 목록을 따로 관리
	// adjacent[n] -> n번째 정점과 연결된 정점 목록
	vector<vector<int>> adjacent(6);
	adjacent[0] = { 1, 3 };
	adjacent[1] = { 0, 2, 3 };
	adjacent[3] = { 4 };
	adjacent[5] = { 4 };


	// Q) 0번 -> 3번 정점이 연결되어 있나요?
	bool connected = false;
	for (int vertex : adjacent[0])
	{
		if (vertex == 3)
		{
			connected = true;
			break;
		}
	}

	// STL
	vector<int>& adj = adjacent[0];
	bool connected2 = (std::find(adj.begin(), adj.end(), 3) != adj.end());
}


void CreateGraph_3()
{
	struct Vertex
	{
		// int data;
	};

	vector<Vertex> v;
	v.resize(6);

	// 정점이 많아지면 간선도 많아지므로
	// - 지하철 노선도 -> 서로 드문 드문 연결 (양옆, 환승역이라면 조금 더 ++)
	// - 페이스북 친구 -> 서로 빽빽하게 연결
	// 누구랑 누구랑 친추를 맺고 있는지 확인을 위해선 리스트를 하나씩 순회해야 한다..
	// 서로 드문 드문 연결된 경우 CreateGraph_2의 방법을 사용하는 것이 좋지만
	// 서로 빽빽하게 연결되어 있는 경우 CreateGraph_3의 메모리를 팔아 성능 향상을 얻는
	// 2차원 배열을 이용하는 것이 더 낫다
	// 연결된 목록을 따로 관리 (행렬처럼)
	// [X][O][X][O][X][X]
	// [O][X][O][O][X][X]
	// [X][X][X][X][X][X]
	// [X][X][X][X][O][X]
	// [X][X][X][X][X][X]
	// [X][X][X][X][O][X]

	// 읽는 방법 : adjacent[from][to]
	// 행렬을 이용한 그래프 표현 (2차원 배열)
	// 메모리 소모가 심하지만, 빠른 접근이 가능하다
	// (간선이 많은 경우 이점이 있다)
	vector<vector<bool>> adjacent(6, vector<bool>(6, false));
	adjacent[0][1] = true;
	adjacent[0][3] = true;
	adjacent[1][0] = true;
	adjacent[1][2] = true;
	adjacent[1][3] = true;
	adjacent[3][4] = true;
	adjacent[5][4] = true;

	// Q) 0번 -> 3번 정점이 연결되어 있나요?
	bool connected = adjacent[0][3];

	// 두번째 그림의 가중치 그래프 표현
	// 연결이 되어있지 않은 경우 -1로 표현
	vector<vector<int>> adjacent2 =
	{
		vector<int> { -1, 15, -1, 35, -1, -1 },
		vector<int> { 15, -1, +5, 10, -1, -1 },
		vector<int> { -1, -1, -1, -1, -1, -1 },
		vector<int> { -1, -1, -1, -1, +5, -1 },
		vector<int> { -1, -1, -1, -1, -1, -1 },
		vector<int> { -1, -1, -1, -1, +5, -1 },
	};

	//adjacent2[0][3] != 1; 로 연결 여부 확인 가능
}

int main()
{
	CreateGraph_1();
	CreateGraph_2();
	CreateGraph_3();
}
```

***

## DFS (깊이 우선 탐색)
- 길이 있으면 끝을 볼 때까지 타고 들어가서 탐색하는 타입
- 재귀 함수 구현
### DFS 구현해보기
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <stack>
#include <queue>
using namespace std;

// DFS (Depth First Search) 깊이 우선 탐색
struct Vertex
{
	// int data;
};

vector<Vertex> vertices;
vector<vector<int>> adjacent; // 인접 목록을 벡터로 관리
vector<bool> visited; // 방문 했는지 여부

void CreateGraph()
{
	vertices.resize(6);	// 정점 6개
	adjacent = vector<vector<int>>(6);

	// 인접 리스트
	/*adjacent[0].push_back(1);
	adjacent[0].push_back(3);
	adjacent[1].push_back(0);
	adjacent[1].push_back(2);
	adjacent[1].push_back(3);
	adjacent[3].push_back(4);
	adjacent[5].push_back(4);*/

	// 인접 행렬
	adjacent = vector<vector<int>>
	{
		{ 0, 1, 0, 1, 0, 0 },
		{ 1, 0, 1, 1, 0, 0 },
		{ 0, 0, 0, 0, 0, 0 },
		{ 0, 0, 0, 0, 1, 0 },
		{ 0, 0, 0, 0, 0, 0 },
		{ 0, 0, 0, 0, 1, 0 },
	};
}

// DFS

void Dfs(int here)
{
	// 방문!
	visited[here] = true;
	cout << "Visited : " << here << endl; // 0 1 2 3 4 5

	// 재귀함수 (끝까지 깊이 들어갔다가 하나씩 돌아나와서 못 찾은 길 실행)
	// 인접 리스트 version
	// 모든 인접 정점을 순회한다
	//for (int i = 0; i < adjacent[here].size(); i++)
	//{
	//	int there = adjacent[here][i];	// 목적지 추출
	//	if (visited[there] == false)
	//		Dfs(there);
	//}

	// 인접 행렬 version
	// 모든 인접 정점을 순회한다
	for (int there = 0; there < 6; there++)
	{
		if (adjacent[here][there] == 0)
			continue;

		// 아직 방문하지 않은 곳이 있으면 방문한다
		if (visited[there] == false)
			Dfs(there);
	}
}

// 5번 정점 같은 끊겨 있는 정점까지 빠짐없이 순회하기 위한 별도의 함수
void DfsAll()
{
	visited = vector<bool>(6, false);

	for (int i = 0; i < 6; i++)
		if (visited[i] == false)
			Dfs(i);
}

int main()
{
	CreateGraph();

	//visited = vector<bool>(6, false);
	//Dfs(0);

	DfsAll();
}
```


***

## BFS (너비 우선 탐색)
- 입구를 기준으로 거리 자체가 우선 (몇 번에 걸쳐서 이동할 수 있는지)
- 큐를 이용하여 예약 시스템 구현
	- 숫자를 *발견*하면 큐에 넣는다
	- 처음 큐에 숫자 '0'이 들어가고 큐가 empty가 false이기 때문에 while문 안으로 들어가서 숫자를 꺼내주게 된다
	- 큐의 front를 꺼내고 *방문*을 하게 된다
	- 그 숫자와 인접한 애들을 발견하면 큐에 예약만 해주고 빠져나오게 된다
- DFS는 발견한 순간 바로 방문하지만 BFS에서는 발견한 순서를 그대로 방문하게 된다
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <stack>
#include <queue>
using namespace std;

// BFS (Breadth First Search) 너비 우선 탐색
struct Vertex
{
	// int data;
};

vector<Vertex> vertices;
vector<vector<int>> adjacent;
vector<bool> discovered;	// 발견 여부 저장 (방문 여부가 아니라)

void CreateGraph()
{
	vertices.resize(6);
	adjacent = vector<vector<int>>(6);

	// 인접 리스트
	/*adjacent[0].push_back(1);
	adjacent[0].push_back(3);
	adjacent[1].push_back(0);
	adjacent[1].push_back(2);
	adjacent[1].push_back(3);
	adjacent[3].push_back(4);
	adjacent[5].push_back(4);*/

	// 인접 행렬
	adjacent = vector<vector<int>>
	{
		{ 0, 1, 0, 1, 0, 0},
		{ 1, 0, 1, 1, 0, 0},
		{ 0, 0, 0, 0, 0, 0},
		{ 0, 0, 0, 0, 1, 0},
		{ 0, 0, 0, 0, 0, 0},
		{ 0, 0, 0, 0, 1, 0},
	};
}

void Bfs(int here)
{
	// 데이터 추적
	// 누구에 의해 발견 되었는지?
	vector<int> parent(6, -1);
	// 시작점에서 얼만큼 떨어져 있는지?
	vector<int> distance(6, -1);

	// 큐는 발견한 순서를 그대로 넣어주는 예약 시스템
	queue<int> q;
	q.push(here);
	discovered[here] = true;	// 발견 시점

	parent[here] = here; // 첫 점은 나 자신에 의해 발견
	distance[here] = 0;

	while (q.empty() == false)
	{
		here = q.front();		// 방문 시점
		q.pop();

		cout << "Visited : " << here << endl;

		//for (int there : adjacent[here])	// 인접 리스트 버전
		for (int there = 0; there < 6; there++)	// 인접 행렬 버전
		{
			if (adjacent[here][there] == 0)		// 인접 행렬 버전
				continue;						// 인접 행렬 버전
			if (discovered[there])
				continue;

			q.push(there);
			discovered[there] = true;	// 발견

			parent[there] = here;
			distance[there] = distance[here] + 1;	// 이전점거리+1 이 새로 발견한 점 거리
		}
	}
}

void BfsAll()
{
	for (int i = 0; i < 6; i++)
		if (discovered[i] == false)
			Bfs(i);
}

int main()
{
	CreateGraph();

	discovered = vector<bool>(6, false);

	//Bfs(0);
	BfsAll();
}
```
![[4-2. BFS.jpg]]

***

### BFS를 이용한 길찾기(Maze) 구현
- Maze의 각 칸을 정점이라고 보고 그래프로 표현한다
- 상하좌우 네 방향으로 초록색끼리 연결이 되어있으면 인접하고 빨간색으로 막혀있으면 인접하지 않다고 판별할 수 있다 (인접 행렬을 만들어주지 않아도 그래프로 표현 가능)
- 시작점부터 가까운 애부터 탐색해서 가까운 애부터 방문을 하게 된다 (큐의 역할)
- BFS를 돌려서 BFS가 완료가 되면 빠져나와서 역으로 추적하면 이게 최단 거리가 된다