# ê·¸ë˜í”„
- í˜„ì‹¤ ì„¸ê³„ì˜ ì‚¬ë¬¼ì´ë‚˜ ì¶”ìƒì ì¸ ê°œë… ê°„ì˜ "ì—°ê²° ê´€ê³„"ë¥¼ í‘œí˜„í•œë‹¤  G = (V, E)
- ì •ì (Vertex): ì‚¬ë¬¼ì´ë‚˜ ê°œë… ë“±ì˜ ë°ì´í„°ë¥¼ í‘œí˜„í•œë‹¤
- ê°„ì„ (Edge): ì •ì ë“¤ì„ ì—°ê²°í•˜ëŠ”ë° ì‚¬ìš©í•œë‹¤
- ê²½ë¡œì˜ ê¸¸ì´: ì •ì ê³¼ ì •ì  ì‚¬ì´ì— ìˆëŠ” ê°„ì„ ì˜ ìˆ˜ ì´ë‹¤
- ì¢…ë¥˜: ê¸°ë³¸, ê°€ì¤‘ì¹˜ ê·¸ë˜í”„, ë°©í–¥ ê·¸ë˜í”„

### ê·¸ë˜í”„ êµ¬í˜„í•´ë³´ê¸°
![[4-1. ê·¸ë˜í”„.png|300]]   >>ì˜ˆì‹œ (ê¸°ë³¸, ê°€ì¤‘ì¹˜ ê·¸ë˜í”„)
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <stack>
#include <queue>
using namespace std;

void CreateGraph_1()
{
	struct Vertex
	{
		// ê°„ì„ ì´ ëª‡ê°œì¸ì§€ ì•Œ ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— vectorë¡œ Vertexë¼ë¦¬ ì„œë¡œ ê°€ë¦¬í‚¤ê²Œë” -> ê°„ì„  ëª©ë¡
		vector<Vertex*> edges;
		// int data;
	};

	// ì •ì  6ê°œ ë§Œë“¤ê¸°
	vector<Vertex> v;
	v.resize(6);

	// ì •ì ë¼ë¦¬ ê°„ì„ ìœ¼ë¡œ ì—°ê²°
	v[0].edges.push_back(&v[1]);
	v[0].edges.push_back(&v[3]);
	v[1].edges.push_back(&v[0]);
	v[1].edges.push_back(&v[2]);
	v[1].edges.push_back(&v[3]);
	v[3].edges.push_back(&v[4]);
	v[5].edges.push_back(&v[4]);

	// Q) 0ë²ˆ -> 3ë²ˆ ì •ì ì´ ì—°ê²°ë˜ì–´ ìˆë‚˜ìš”?
	bool connected = false;
	for (Vertex* edge : v[0].edges)
	{
		if (edge == &v[3])
		{
			connected = true;
			break;
		}
	}
}

void CreateGraph_2()
{
	struct Vertex
	{
		// vector<Vertex*> edges;
		// ê¹”ë”í•˜ê²Œ ì •ì ë¼ë¦¬ ì—°ê²° ê´€ê³„ë¥¼ ë³„ë„ì˜ ë°ì´í„°ë¡œ ë¹¼ì„œ ê´€ë¦¬
		// ë‚˜ì¤‘ì— ì‹¤ì œ ë°ì´í„°ì™€ ì—°ê²° ì—¬ë¶€ ì¦‰ ê°„ì„  ì—¬ë¶€ë¥¼ ë¶„ë¦¬í•´ì„œ ê´€ë¦¬
		// int data;
	};

	vector<Vertex> v;
	v.resize(6);

	// ì—°ê²°ëœ ëª©ë¡ì„ ë”°ë¡œ ê´€ë¦¬
	// adjacent[n] -> në²ˆì§¸ ì •ì ê³¼ ì—°ê²°ëœ ì •ì  ëª©ë¡
	vector<vector<int>> adjacent(6);
	adjacent[0] = { 1, 3 };
	adjacent[1] = { 0, 2, 3 };
	adjacent[3] = { 4 };
	adjacent[5] = { 4 };


	// Q) 0ë²ˆ -> 3ë²ˆ ì •ì ì´ ì—°ê²°ë˜ì–´ ìˆë‚˜ìš”?
	bool connected = false;
	for (int vertex : adjacent[0]) // adjacent[0] ì•ˆì˜ ëª¨ë“  ìˆ˜ íƒìƒ‰
	{
		if (vertex == 3)
		{
			connected = true;
			break;
		}
	}

	// STL ì´ìš©í•œ ì—°ê²° ê²€ìƒ‰ ë°©ë²•
	vector<int>& adj = adjacent[0];
	bool connected2 = (std::find(adj.begin(), adj.end(), 3) != adj.end());
}


void CreateGraph_3()
{
	struct Vertex
	{
		// int data;
	};

	vector<Vertex> v;
	v.resize(6);

	// ì •ì ì´ ë§ì•„ì§€ë©´ ê°„ì„ ë„ ë§ì•„ì§€ë¯€ë¡œ
	// - ì§€í•˜ì²  ë…¸ì„ ë„ -> ì„œë¡œ ë“œë¬¸ ë“œë¬¸ ì—°ê²° (ì–‘ì˜†, í™˜ìŠ¹ì—­ì´ë¼ë©´ ì¡°ê¸ˆ ë” ++)
	// - í˜ì´ìŠ¤ë¶ ì¹œêµ¬ -> ì„œë¡œ ë¹½ë¹½í•˜ê²Œ ì—°ê²°
	// ëˆ„êµ¬ë‘ ëˆ„êµ¬ë‘ ì¹œì¶”ë¥¼ ë§ºê³  ìˆëŠ”ì§€ í™•ì¸ì„ ìœ„í•´ì„  ë¦¬ìŠ¤íŠ¸ë¥¼ í•˜ë‚˜ì”© ìˆœíšŒí•´ì•¼ í•œë‹¤..
	// ì„œë¡œ ë“œë¬¸ ë“œë¬¸ ì—°ê²°ëœ ê²½ìš° CreateGraph_2ì˜ ë°©ë²•ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ì§€ë§Œ
	// ì„œë¡œ ë¹½ë¹½í•˜ê²Œ ì—°ê²°ë˜ì–´ ìˆëŠ” ê²½ìš° CreateGraph_3ì˜ ë©”ëª¨ë¦¬ë¥¼ íŒ”ì•„ ì„±ëŠ¥ í–¥ìƒì„ ì–»ëŠ”
	// "2ì°¨ì› ë°°ì—´"ì„ ì´ìš©í•˜ëŠ” ê²ƒì´ ë” ë‚«ë‹¤
	// ì—°ê²°ëœ ëª©ë¡ì„ ë”°ë¡œ ê´€ë¦¬ (í–‰ë ¬ì²˜ëŸ¼)
	// [X][O][X][O][X][X]
	// [O][X][O][O][X][X]
	// [X][X][X][X][X][X]
	// [X][X][X][X][O][X]
	// [X][X][X][X][X][X]
	// [X][X][X][X][O][X]

	// ì½ëŠ” ë°©ë²• : adjacent[from][to]
	// í–‰ë ¬ì„ ì´ìš©í•œ ê·¸ë˜í”„ í‘œí˜„ (2ì°¨ì› ë°°ì—´)
	// ë©”ëª¨ë¦¬ ì†Œëª¨ê°€ ì‹¬í•˜ì§€ë§Œ, ë¹ ë¥¸ ì ‘ê·¼ì´ ê°€ëŠ¥í•˜ë‹¤ (ê°„ì„ ì´ ë§ì€ ê²½ìš° ì´ì ì´ ìˆë‹¤)
	vector<vector<bool>> adjacent(6, vector<bool>(6, false));
	adjacent[0][1] = true;
	adjacent[0][3] = true;
	adjacent[1][0] = true;
	adjacent[1][2] = true;
	adjacent[1][3] = true;
	adjacent[3][4] = true;
	adjacent[5][4] = true;

	// Q) 0ë²ˆ -> 3ë²ˆ ì •ì ì´ ì—°ê²°ë˜ì–´ ìˆë‚˜ìš”?
	bool connected = adjacent[0][3];

	// ë‘ë²ˆì§¸ ê·¸ë¦¼ì˜ ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ í‘œí˜„ (ì—°ê²°ì´ ë˜ì–´ìˆì§€ ì•Šì€ ê²½ìš° -1)
	vector<vector<int>> adjacent2 =
	{
		vector<int> { -1, 15, -1, 35, -1, -1 },
		vector<int> { 15, -1, +5, 10, -1, -1 },
		vector<int> { -1, -1, -1, -1, -1, -1 },
		vector<int> { -1, -1, -1, -1, +5, -1 },
		vector<int> { -1, -1, -1, -1, -1, -1 },
		vector<int> { -1, -1, -1, -1, +5, -1 },
	};

	//adjacent2[0][3] != 1; ë¡œ ì—°ê²° ì—¬ë¶€ í™•ì¸ ê°€ëŠ¥
}

int main()
{
	CreateGraph_1();
	CreateGraph_2();
	CreateGraph_3();
}
```

***

## DFS (ê¹Šì´ ìš°ì„  íƒìƒ‰)
- ê²½ë¡œê°€ ìˆìœ¼ë©´ ëì„ ë³¼ ë•Œê¹Œì§€ íƒ€ê³  ë“¤ì–´ê°€ì„œ íƒìƒ‰í•˜ëŠ” íƒ€ì…
- **ì¬ê·€í•¨ìˆ˜**ë¥¼ ì´ìš©í•œë‹¤
- ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ë²„ì „ì€ adjacent ìì²´ê°€ ë‚˜ì™€ ì‹¤ì§ˆì ìœ¼ë¡œ ì—°ê²°ëœ ì •ì (there)ì˜ ë²ˆí˜¸ë¥¼ ë“¤ê³  ìˆëŠ” ë°˜ë©´ ì¸ì ‘ í–‰ë ¬ ë²„ì „ì€ ëª¨ë“  ì ë“¤ì´ adjacent ê°’ì„ ê°–ê³  ìˆëŠ”ë° ì´ ê°’ì´ 0ì¸ì§€ 1ì¸ì§€ì— ë”°ë¼ì„œ ì—°ê²° ì—¬ë¶€ë¥¼ íŒë‹¨í•œë‹¤
### DFS êµ¬í˜„í•´ë³´ê¸°
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <stack>
#include <queue>
using namespace std;

// DFS (Depth First Search) ê¹Šì´ ìš°ì„  íƒìƒ‰
struct Vertex
{
	// int data;
};

vector<Vertex> vertices;
vector<vector<int>> adjacent; // ì¸ì ‘ ëª©ë¡ì„ ë²¡í„°ë¡œ ê´€ë¦¬
vector<bool> visited; // ë°©ë¬¸ í–ˆëŠ”ì§€ ì—¬ë¶€

void CreateGraph()
{
	vertices.resize(6);	// ì •ì  6ê°œ
	adjacent = vector<vector<int>>(6);

	// ì¸ì ‘ ë¦¬ìŠ¤íŠ¸
	/*adjacent[0].push_back(1);  // vector<int> adjacent[0]
	adjacent[0].push_back(3);
	adjacent[1].push_back(0);
	adjacent[1].push_back(2);
	adjacent[1].push_back(3);
	adjacent[3].push_back(4);
	adjacent[5].push_back(4);*/

	// ì¸ì ‘ í–‰ë ¬
	adjacent = vector<vector<int>>
	{
		{ 0, 1, 0, 1, 0, 0 },
		{ 1, 0, 1, 1, 0, 0 },
		{ 0, 0, 0, 0, 0, 0 },
		{ 0, 0, 0, 0, 1, 0 },
		{ 0, 0, 0, 0, 0, 0 },
		{ 0, 0, 0, 0, 1, 0 },
	};
}

// DFS
void Dfs(int here)  // here: í˜„ì¬ì˜ ìœ„ì¹˜
{
	// ë°©ë¬¸!
	visited[here] = true;
	cout << "Visited : " << here << endl; // 0 1 2 3 4 5

	// ì¬ê·€í•¨ìˆ˜ (ëê¹Œì§€ ê¹Šì´ ë“¤ì–´ê°”ë‹¤ê°€ í•˜ë‚˜ì”© ëŒì•„ë‚˜ì™€ì„œ ëª» ì°¾ì€ ê¸¸ ì‹¤í–‰) ğŸ”¥
	// ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ version
	// ëª¨ë“  ì¸ì ‘ ì •ì ì„ ìˆœíšŒí•œë‹¤
	//for (int i = 0; i < adjacent[here].size(); i++)
	//{
	//	int there = adjacent[here][i];	// ëª©ì ì§€ ì¶”ì¶œ
	//	if (visited[there] == false)
	//		Dfs(there);
	//}

	// ì¸ì ‘ í–‰ë ¬ version
	for (int there = 0; there < 6; there++)
	{
		if (adjacent[here][there] == 0)
			continue;

		// ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì€ ê³³ì´ ìˆìœ¼ë©´ ë°©ë¬¸í•œë‹¤
		if (visited[there] == false)
			Dfs(there);
	}
}

// 5ë²ˆ ì •ì  ê°™ì€ ëŠê²¨ ìˆëŠ” ì •ì ê¹Œì§€ ë¹ ì§ì—†ì´ ìˆœíšŒí•˜ê¸° ìœ„í•œ ë³„ë„ì˜ í•¨ìˆ˜
void DfsAll()
{
	visited = vector<bool>(6, false);

	for (int i = 0; i < 6; i++)
		if (visited[i] == false)
			Dfs(i);
}

int main()
{
	CreateGraph();

	//visited = vector<bool>(6, false);
	//Dfs(0);

	DfsAll();
}
```


***

## BFS (ë„ˆë¹„ ìš°ì„  íƒìƒ‰)
- ì…êµ¬ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê±°ë¦¬ê°€ ê°€ê¹Œìš´ ì• ë¶€í„° ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰í•œë‹¤ (ëª‡ ë²ˆì— ê±¸ì³ì„œ ì´ë™í•  ìˆ˜ ìˆëŠ”ì§€)
- **í**ë¥¼ ì´ìš©í•˜ì—¬ ì˜ˆì•½ ì‹œìŠ¤í…œ êµ¬í˜„ (íê°€ ë°œê²¬í•œ ì• ë“¤ ëª©ë¡ì„ ê´€ë¦¬í•œë‹¤ - ì„ ì…ì„ ì¶œ êµ¬ì¡°)
	- ìˆ«ìë¥¼ *ë°œê²¬*í•˜ë©´ íì— ë„£ëŠ”ë‹¤
	- ì²˜ìŒ íì— ìˆ«ì '0'ì´ ë“¤ì–´ê°€ê³  íê°€ emptyê°€ falseì´ê¸° ë•Œë¬¸ì— whileë¬¸ ì•ˆìœ¼ë¡œ ë“¤ì–´ê°€ì„œ ìˆ«ìë¥¼ êº¼ë‚´ì£¼ê²Œ ëœë‹¤
	- íì˜ frontë¥¼ êº¼ë‚´ê³  *ë°©ë¬¸*ì„ í•˜ê²Œ ëœë‹¤
	- ê·¸ ìˆ«ìì™€ ì¸ì ‘í•œ ì• ë“¤ì„ ë°œê²¬í•˜ë©´ íì— ì˜ˆì•½ë§Œ í•´ì£¼ê³  ë¹ ì ¸ë‚˜ì˜¤ê²Œ ëœë‹¤
- DFSëŠ” ë°œê²¬í•œ ìˆœê°„ ë°”ë¡œ ë°©ë¬¸í•˜ì§€ë§Œ BFSì—ì„œëŠ” ë°œê²¬í•œ ìˆœì„œë¥¼ ê·¸ëŒ€ë¡œ ë°©ë¬¸í•˜ê²Œ ëœë‹¤
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <stack>
#include <queue>
using namespace std;

// BFS (Breadth First Search) ë„ˆë¹„ ìš°ì„  íƒìƒ‰
struct Vertex
{
	// int data;
};

vector<Vertex> vertices;
vector<vector<int>> adjacent;
vector<bool> discovered;	// ë°œê²¬ ì—¬ë¶€ ì €ì¥ (ë°©ë¬¸ ì—¬ë¶€ê°€ ì•„ë‹ˆë¼)

void CreateGraph()
{
	vertices.resize(6);
	adjacent = vector<vector<int>>(6);

	// ì¸ì ‘ ë¦¬ìŠ¤íŠ¸
	/*adjacent[0].push_back(1);
	adjacent[0].push_back(3);
	adjacent[1].push_back(0);
	adjacent[1].push_back(2);
	adjacent[1].push_back(3);
	adjacent[3].push_back(4);
	adjacent[5].push_back(4);*/

	// ì¸ì ‘ í–‰ë ¬
	adjacent = vector<vector<int>>
	{
		{ 0, 1, 0, 1, 0, 0},
		{ 1, 0, 1, 1, 0, 0},
		{ 0, 0, 0, 0, 0, 0},
		{ 0, 0, 0, 0, 1, 0},
		{ 0, 0, 0, 0, 0, 0},
		{ 0, 0, 0, 0, 1, 0},
	};
}

void Bfs(int here)
{
	// ë°ì´í„° ì¶”ì 
	// ëˆ„êµ¬ì— ì˜í•´ ë°œê²¬ ë˜ì—ˆëŠ”ì§€?
	vector<int> parent(6, -1);
	// ì‹œì‘ì ì—ì„œ ì–¼ë§Œí¼ ë–¨ì–´ì ¸ ìˆëŠ”ì§€?
	vector<int> distance(6, -1);

	// íëŠ” ë°œê²¬í•œ ìˆœì„œë¥¼ ê·¸ëŒ€ë¡œ ë„£ì–´ì£¼ëŠ” ì˜ˆì•½ ì‹œìŠ¤í…œ
	queue<int> q;
	q.push(here);
	discovered[here] = true;	// ë°œê²¬ ì‹œì 

	parent[here] = here; // ì²« ì ì€ ë‚˜ ìì‹ ì— ì˜í•´ ë°œê²¬
	distance[here] = 0;

	while (q.empty() == false)
	{
		here = q.front();		// ë°©ë¬¸ ì‹œì  (íì˜ ë°ì´í„°ë¥¼ êº¼ëƒ„)
		q.pop();

		cout << "Visited : " << here << endl;

		/*for (int there : adjacent[here])	// ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ ë²„ì „
		{
			if (discovered[there])
				continue;

			q.push(there);
			discovered[there] = true;	// ë°œê²¬

			parent[there] = here;
			distance[there] = distance[here] + 1;	// ì´ì „ì ê±°ë¦¬+1 ì´ ìƒˆë¡œ ë°œê²¬í•œ ì  ê±°ë¦¬
		}*/

		for (int there = 0; there < 6; there++)  // ì¸ì ‘ í–‰ë ¬ ë²„ì „
		{
			if (adjacent[here][there] == 0)
				continue;
			if (discovered[there])
				continue;

			q.push(there);
			discovered[there] = true;

			parent[there] = here;
			distance[there] = distance[here] + 1;
		}
	}
}

void BfsAll()
{
	for (int i = 0; i < 6; i++)
		if (discovered[i] == false)
			Bfs(i);
}

int main()
{
	CreateGraph();

	discovered = vector<bool>(6, false);

	//Bfs(0);
	BfsAll();
}
```
![[4-2. BFS.jpg]]

***

### BFSë¥¼ ì´ìš©í•œ ê¸¸ì°¾ê¸°(Maze) êµ¬í˜„
- Mazeì˜ ê° ì¹¸ì„ ì •ì ì´ë¼ê³  ë³´ê³  ê·¸ë˜í”„ë¡œ í‘œí˜„í•œë‹¤
- ìƒí•˜ì¢Œìš° ë„¤ ë°©í–¥ìœ¼ë¡œ ì´ˆë¡ìƒ‰ë¼ë¦¬ ì—°ê²°ì´ ë˜ì–´ìˆìœ¼ë©´ ì¸ì ‘í•˜ê³  ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ë§‰í˜€ìˆìœ¼ë©´ ì¸ì ‘í•˜ì§€ ì•Šë‹¤ê³  íŒë³„í•  ìˆ˜ ìˆë‹¤ (ì¸ì ‘ í–‰ë ¬ì„ ë§Œë“¤ì–´ì£¼ì§€ ì•Šì•„ë„ ê·¸ë˜í”„ë¡œ í‘œí˜„ ê°€ëŠ¥)
- ì‹œì‘ì ë¶€í„° ê°€ê¹Œìš´ ì• ë¶€í„° íƒìƒ‰í•´ì„œ ê°€ê¹Œìš´ ì• ë¶€í„° ë°©ë¬¸ì„ í•˜ê²Œ ëœë‹¤ (íì˜ ì—­í• )
- BFSë¥¼ ëŒë ¤ì„œ BFSê°€ ì™„ë£Œê°€ ë˜ë©´ ë¹ ì ¸ë‚˜ì™€ì„œ ì—­ìœ¼ë¡œ ì¶”ì í•˜ë©´ ì´ê²Œ ìµœë‹¨ ê±°ë¦¬ê°€ ëœë‹¤
- **ë‹¨ì ...**
	- ëª©ì ì§€ë¥¼ ì°ê³  ê°€ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ëª¨ë“  ì ì„ ì‹œì‘ì ë¶€í„° ê°€ê¹Œìš´ ìˆœì„œëŒ€ë¡œ ìŠ¤ìº”í•œë‹¤ëŠ” ë‹¨ì ì´ ì¡´ì¬í•œë‹¤
	- ìƒí•˜ì¢Œìš° ë¿ë§Œ ì•„ë‹ˆë¼ ëŒ€ê°ì„  ì´ë™ì„ ì§€ì›ì„ í•´ì•¼ í•  ë•Œ ì•„ì‰½ë‹¤ (ìˆ˜í‰, ìˆ˜ì§ìœ¼ë¡œ ì´ë™í•˜ëŠ” ê±¸ 1ì´ë¼ê³  ë†“ìœ¼ë©´ ëŒ€ê°ì„ ìœ¼ë¡œ ì´ë™í•  ë•Œ ì–¼ë§ˆì˜ *ë…¸ë ¥*ì´ ë“ ë‹¤ëŠ” ì¡°ê±´ì„ ì„¤ì •í•  ìˆ˜ ì—†ë‹¤)

#### pch.h
```cpp
#pragma once

#include "Types.h"
#include <windows.h>
#include <iostream>
#include <vector>
#include <queue>
#include <map>
using namespace std;

struct Pos
{
	bool operator==(Pos& other)
	{
		return y == other.y && x == other.x;
	}

	bool operator!=(Pos& other)
	{
		return !(*this == other);
	}

	bool operator<(const Pos& other) const
	{
		if (y != other.y)
			return y < other.y;
		return x < other.x;
	}

	Pos operator+(Pos& other)
	{
		Pos ret;
		ret.y = y + other.y;
		ret.x = x + other.x;
		return ret;
	}

	Pos& operator+=(Pos& other)
	{
		y += other.y;
		x += other.x;
		return *this;
	}

	int32 y = 0;
	int32 x = 0;
};

enum Dir
{
	DIR_UP = 0,
	DIR_LEFT = 1,
	DIR_DOWN = 2,
	DIR_RIGHT = 3,

	DIR_COUNT = 4
};
```

#### Player.h
```cpp
#pragma once

class Board;

class Player
{
	enum
	{
		MOVE_TICK = 100
	};

public:
	void		Init(Board* board);
	void		Update(uint64 deltaTick);

	void		SetPos(Pos pos) { _pos = pos; }
	Pos			GetPos() { return _pos; }

	bool		CanGo(Pos pos);

private:
	void		RightHand();
	void		Bfs();

private:
	Pos			_pos = {};
	int32		_dir = DIR_UP;
	Board*		_board = nullptr;

	vector<Pos>	_path;
	uint32		_pathIndex = 0;
	uint64		_sumTick = 0;
};
```

#### Board.h
```cpp
#pragma once
#include "ConsoleHelper.h"

class Player;

enum
{
	BOARD_MAX_SIZE = 100
};

enum class TileType
{
	NONE = 0,
	EMPTY,
	WALL,
};

class Board
{
public:
	Board();
	~Board();

	void			Init(int32 size, Player* player);
	void			Render();

	void			GenerateMap();
	TileType		GetTileType(Pos pos);
	ConsoleColor	GetTileColor(Pos pos);

	Pos				GetEnterPos() { return Pos{ 1, 1 }; }
	Pos				GetExitPos() { return Pos{ _size - 2, _size - 2 }; }
	int32			GetSize() { return _size; }

private:
	TileType		_tile[BOARD_MAX_SIZE][BOARD_MAX_SIZE] = {};
	int32			_size = 0;
	Player*			_player = nullptr;
};
```

#### Board.cpp
```cpp
#include "pch.h"
#include "Board.h"
#include "ConsoleHelper.h"
#include "Player.h"

const char* TILE = "â– ";

Board::Board()
{

}

Board::~Board()
{

}

void Board::Init(int32 size, Player* player)
{
	_size = size;
	_player = player;

	GenerateMap();
}

void Board::Render()
{
	ConsoleHelper::SetCursorPosition(0, 0);
	ConsoleHelper::ShowConsoleCursor(false);

	for (int32 y = 0; y < 25; y++)
	{
		for (int32 x = 0; x < 25; x++)
		{
			ConsoleColor color = GetTileColor(Pos{ y, x });
			ConsoleHelper::SetCursorColor(color);
			cout << TILE;
		}

		cout << endl;
	}
}

// Binary Tree ë¯¸ë¡œ ìƒì„± ì•Œê³ ë¦¬ì¦˜
// - Mazes For Programmers
void Board::GenerateMap()
{
	for (int32 y = 0; y < _size; y++)
	{
		for (int32 x = 0; x < _size; x++)
		{
			if (x % 2 == 0 || y % 2 == 0)
				_tile[y][x] = TileType::WALL;
			else
				_tile[y][x] = TileType::EMPTY;
		}
	}

	// ëœë¤ìœ¼ë¡œ ìš°ì¸¡ í˜¹ì€ ì•„ë˜ë¡œ ê¸¸ì„ ëš«ëŠ” ì‘ì—…
	for (int32 y = 0; y < _size; y++)
	{
		for (int32 x = 0; x < _size; x++)
		{
			if (x % 2 == 0 || y % 2 == 0)
				continue;
			if (y == _size - 2 && x == _size - 2)
				continue;

			if (y == _size - 2)
			{
				_tile[y][x + 1] = TileType::EMPTY;
				continue;
			}

			if (x == _size - 2)
			{
				_tile[y + 1][x] = TileType::EMPTY;
				continue;
			}

			const int32 randValue = ::rand() % 2;
			if (randValue == 0)
			{
				_tile[y][x + 1] = TileType::EMPTY;
			}
			else
			{
				_tile[y + 1][x] = TileType::EMPTY;
			}
		}
	}
}

TileType Board::GetTileType(Pos pos)  // ì–´ë–¤ ìœ„ì¹˜ì— ì–´ë–¤ íƒ€ì¼ì´ ìˆëŠ”ì§€ ì²´í¬ í•¨ìˆ˜
{
	if (pos.x < 0 || pos.x >= _size) // ë²”ìœ„ ì²´í¬
		return TileType::NONE;

	if (pos.y < 0 || pos.y >= _size)
		return TileType::NONE;

	return _tile[pos.y][pos.x];
}

ConsoleColor Board::GetTileColor(Pos pos) // ì½˜ì†” ì»¬ëŸ¬ë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
{
	if (_player && _player->GetPos() == pos)
		return ConsoleColor::YELLOW;

	if (GetExitPos() == pos)
		return ConsoleColor::BLUE;

	TileType tileType = GetTileType(pos);

	switch (tileType)
	{
	case TileType::EMPTY:
		return ConsoleColor::GREEN;
	case TileType::WALL:
		return ConsoleColor::RED;
	}

	return ConsoleColor::WHITE;
}
```

#### Player.cpp
```cpp
#include "pch.h"
#include "Player.h"
#include "Board.h"
#include <stack>

void Player::Init(Board* board)
{
	_pos = board->GetEnterPos();
	_board = board;

	//RightHand();
	Bfs();
}

void Player::Update(uint64 deltaTick)
{
	if (_pathIndex >= _path.size())
		return;

	_sumTick += deltaTick;
	if (_sumTick >= MOVE_TICK)
	{
		_sumTick = 0;

		_pos = _path[_pathIndex];
		_pathIndex++;
	}
}

bool Player::CanGo(Pos pos)
{
	TileType tileType = _board->GetTileType(pos);
	return tileType == TileType::EMPTY;
}

void Player::RightHand()
{
	Pos pos = _pos;

	_path.clear();
	_path.push_back(pos);

	// ëª©ì ì§€ ë„ì°©í•˜ê¸° ì „ì—ëŠ” ê³„ì† ì‹¤í–‰
	Pos dest = _board->GetExitPos();

	Pos front[4] =
	{
		Pos { -1, 0},	// UP
		Pos { 0, -1},	// LEFT
		Pos { 1, 0},	// DOWN
		Pos { 0, 1},	// RIGHT
	};

	while (pos != dest)
	{
		// 1. í˜„ì¬ ë°”ë¼ë³´ëŠ” ë°©í–¥ì„ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸.
		int32 newDir = (_dir - 1 + DIR_COUNT) % DIR_COUNT;
		if (CanGo(pos + front[newDir]))
		{
			// ì˜¤ë¥¸ìª½ ë°©í–¥ìœ¼ë¡œ 90ë„ íšŒì „.
			_dir = newDir;
			// ì•ìœ¼ë¡œ í•œ ë³´ ì „ì§„.
			pos += front[_dir];

			_path.push_back(pos);
		}
		// 2. í˜„ì¬ ë°”ë¼ë³´ëŠ” ë°©í–¥ì„ ê¸°ì¤€ìœ¼ë¡œ ì „ì§„í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸.
		else if (CanGo(pos + front[_dir]))
		{
			// ì•ìœ¼ë¡œ í•œ ë³´ ì „ì§„.
			pos += front[_dir];

			_path.push_back(pos);
		}
		else
		{
			// ì™¼ìª½ ë°©í–¥ìœ¼ë¡œ 90ë„ íšŒì „.
			_dir = (_dir + 1) % DIR_COUNT;
		}
	}

	stack<Pos> s;

	for (int i = 0; i < _path.size() - 1; i++)
	{
		if (s.empty() == false && s.top() == _path[i + 1])
			s.pop();
		else
			s.push(_path[i]);
	}

	// ëª©ì ì§€ ë„ì°©
	if (_path.empty() == false)
		s.push(_path.back());

	vector<Pos> path;
	while (s.empty() == false)
	{
		path.push_back(s.top());
		s.pop();
	}

	std::reverse(path.begin(), path.end());

	_path = path;
}

void Player::Bfs()
{
	Pos pos = _pos;

	// ëª©ì ì§€ ë„ì°©í•˜ê¸° ì „ì—ëŠ” ê³„ì† ì‹¤í–‰
	Pos dest = _board->GetExitPos();

	Pos front[4] =
	{
		Pos { -1, 0},	// UP
		Pos { 0, -1},	// LEFT
		Pos { 1, 0},	// DOWN
		Pos { 0, 1},	// RIGHT
	};

	const int32 size = _board->GetSize();		// ë§µì˜ í¬ê¸° ê°€ì ¸ì˜¤ê¸°
	vector<vector<bool>> discovered(size, vector<bool>(size, false));	// ì´ì¤‘ ë²¡í„°
	// vector(í¬ê¸°, ì´ˆê¸°í™”ê°’) : discovered.push_back(vector<bool>(size, false))ì„ sizeë§Œí¼ í•´ì¤€ê²ƒê³¼ ë™ì¼

	//vector<vector<Pos>> parent;
	// parent[A] = B; -> AëŠ” Bë¡œ ì¸í•´ ë°œê²¬í•¨
	map<Pos, Pos> parent;

	queue<Pos> q;
	q.push(pos);
	discovered[pos.y][pos.x] = true;
	parent[pos] = pos;

	while (q.empty() == false)
	{
		pos = q.front();
		q.pop();

		// ë°©ë¬¸!
		if (pos == dest)	// ëª©ì ì§€ ë„ë‹¬
			break;

		for (int32 dir = 0; dir < 4; dir++) // ìƒí•˜ì¢Œìš°ë¡œ ì´ë™
		{
			Pos nextPos = pos + front[dir];
			// ê°ˆ ìˆ˜ ìˆëŠ” ì§€ì—­ì€ ë§ëŠ”ì§€ í™•ì¸
			if (CanGo(nextPos) == false)
				continue;
			// ì´ë¯¸ ë°œê²¬í•œ ì§€ì—­ì¸ì§€ í™•ì¸
			if (discovered[nextPos.y][nextPos.x])
				continue;

			q.push(nextPos);	// ë°œê²¬!!
			discovered[nextPos.y][nextPos.x] = true;
			parent[nextPos] = pos;
		}
	}
	_path.clear();
	// ê±°ê¾¸ë¡œ ê±°ìŠ¬ëŸ¬ ì˜¬ë¼ê°„ë‹¤ (ë¶€ëª¨ê°€ ëˆ„êµ¬ì¸ì§€ ì¶”ì )
	pos = dest;

	while (true)
	{
		_path.push_back(pos);	// pathì— ë°€ì–´ ë†“ê³  frontë¥¼ í†µí•´ ì›ì¸ ì¶”ì  ê°€ëŠ¥

		// ì‹œì‘ì ì€ ìì‹ ì´ ê³§ ë¶€ëª¨ì´ë‹¤
		if (pos == parent[pos])
			break;

		pos = parent[pos];
	}

	std::reverse(_path.begin(), _path.end());
}
```
#### Maze.cpp
```cpp
#include "pch.h"
#include <iostream>
#include "ConsoleHelper.h"
#include "Board.h"
#include "Player.h"

Board board;
Player player;

int main()
{
	::srand(static_cast<unsigned>(time(nullptr)));

	board.Init(25, &player);
	player.Init(&board);

	uint64 lastTick = 0;
	while (true)
	{
#pragma region í”„ë ˆì„ ê´€ë¦¬
		const uint64 currentTick = ::GetTickCount64();
		const uint64 deltaTick = currentTick - lastTick;
		lastTick = currentTick;
#pragma endregion

		// ì…ë ¥

		// ë¡œì§
		player.Update(deltaTick);

		// ë Œë”ë§
		board.Render();
	}
}
```



