# 그래프
- 현실 세계의 사물이나 추상적인 개념 간의 연결 관계를 표현
- 정점(Vertex): 사물이나 개념 등의 데이터를 표현
- 간선(Edge): 정점들을 연결하는데 사용
- 종류: 기본, 가중치 그래프, 방향 그래프
### 그래프 구현해보기
![[4-1. 그래프.png|300]]   >>예시 (기본, 가중치 그래프)
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <stack>
#include <queue>
using namespace std;

void CreateGraph_1()
{
	struct Vertex
	{
		// 간선이 몇개인지 알 수 없기 때문에 vector로 Vertex끼리 서로 가리키게끔 -> 간선 목록
		vector<Vertex*> edges;
		// int data;
	};

	vector<Vertex> v;
	v.resize(6);

	v[0].edges.push_back(&v[1]);
	v[0].edges.push_back(&v[3]);
	v[1].edges.push_back(&v[0]);
	v[1].edges.push_back(&v[2]);
	v[1].edges.push_back(&v[3]);
	v[3].edges.push_back(&v[4]);
	v[5].edges.push_back(&v[4]);

	// Q) 0번 -> 3번 정점이 연결되어 있나요?
	bool connected = false;
	for (Vertex* edge : v[0].edges)
	{
		if (edge == &v[3])
		{
			connected = true;
			break;
		}
	}
}

void CreateGraph_2()
{
	struct Vertex
	{
		// 깔끔하게 정점끼리 연결 관계를 별도의 데이터로 빼서 관리
		// 나중에 실제 데이터와 연결 여부 즉 간선 여부를 분리해서 관리
		// int data;
	};

	vector<Vertex> v;
	v.resize(6);

	// 연결된 목록을 따로 관리
	// adjacent[n] -> n번째 정점과 연결된 정점 목록
	vector<vector<int>> adjacent(6);
	adjacent[0] = { 1, 3 };
	adjacent[1] = { 0, 2, 3 };
	adjacent[3] = { 4 };
	adjacent[5] = { 4 };


	// Q) 0번 -> 3번 정점이 연결되어 있나요?
	bool connected = false;
	for (int vertex : adjacent[0])
	{
		if (vertex == 3)
		{
			connected = true;
			break;
		}
	}

	// STL
	vector<int>& adj = adjacent[0];
	bool connected2 = (std::find(adj.begin(), adj.end(), 3) != adj.end());
}


void CreateGraph_3()
{
	struct Vertex
	{
		// int data;
	};

	vector<Vertex> v;
	v.resize(6);

	// 정점이 많아지면 간선도 많아지므로
	// - 지하철 노선도 -> 서로 드문 드문 연결 (양옆, 환승역이라면 조금 더 ++)
	// - 페이스북 친구 -> 서로 빽빽하게 연결
	// 누구랑 누구랑 친추를 맺고 있는지 확인을 위해선 리스트를 하나씩 순회해야 한다..
	// 서로 드문 드문 연결된 경우 CreateGraph_2의 방법을 사용하는 것이 좋지만
	// 서로 빽빽하게 연결되어 있는 경우 CreateGraph_3의 메모리를 팔아 성능 향상을 얻는
	// 2차원 배열을 이용하는 것이 더 낫다
	// 연결된 목록을 따로 관리 (행렬처럼)
	// [X][O][X][O][X][X]
	// [O][X][O][O][X][X]
	// [X][X][X][X][X][X]
	// [X][X][X][X][O][X]
	// [X][X][X][X][X][X]
	// [X][X][X][X][O][X]

	// 읽는 방법 : adjacent[from][to]
	// 행렬을 이용한 그래프 표현 (2차원 배열)
	// 메모리 소모가 심하지만, 빠른 접근이 가능하다
	// (간선이 많은 경우 이점이 있다)
	vector<vector<bool>> adjacent(6, vector<bool>(6, false));
	adjacent[0][1] = true;
	adjacent[0][3] = true;
	adjacent[1][0] = true;
	adjacent[1][2] = true;
	adjacent[1][3] = true;
	adjacent[3][4] = true;
	adjacent[5][4] = true;

	// Q) 0번 -> 3번 정점이 연결되어 있나요?
	bool connected = adjacent[0][3];

	// 두번째 그림의 가중치 그래프 표현
	// 연결이 되어있지 않은 경우 -1로 표현
	vector<vector<int>> adjacent2 =
	{
		vector<int> { -1, 15, -1, 35, -1, -1 },
		vector<int> { 15, -1, +5, 10, -1, -1 },
		vector<int> { -1, -1, -1, -1, -1, -1 },
		vector<int> { -1, -1, -1, -1, +5, -1 },
		vector<int> { -1, -1, -1, -1, -1, -1 },
		vector<int> { -1, -1, -1, -1, +5, -1 },
	};

	//adjacent2[0][3] != 1; 로 연결 여부 확인 가능
}

int main()
{
	CreateGraph_1();
	CreateGraph_2();
	CreateGraph_3();
}
```

***

## DFS (깊이 우선 탐색)
- 길이 있으면 끝을 볼 때까지 타고 들어가서 탐색하는 타입

### DFS 구현해보기
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <stack>
#include <queue>
using namespace std;


struct Vertex
{
	// int data;
};

vector<Vertex> vertices;
vector<vector<int>> adjacent; // 인접 목록을 벡터로 관리
vector<bool> visited; // 방문 했는지 여부

void CreateGraph()
{
	vertices.resize(6);	// 정점 6개
	adjacent = vector<vector<int>>(6);

	// 인접 리스트
	/*adjacent[0].push_back(1);
	adjacent[0].push_back(3);
	adjacent[1].push_back(0);
	adjacent[1].push_back(2);
	adjacent[1].push_back(3);
	adjacent[3].push_back(4);
	adjacent[5].push_back(4);*/

	// 인접 행렬
	adjacent = vector<vector<int>>
	{
		{ 0, 1, 0, 1, 0, 0 },
		{ 1, 0, 1, 1, 0, 0 },
		{ 0, 0, 0, 0, 0, 0 },
		{ 0, 0, 0, 0, 1, 0 },
		{ 0, 0, 0, 0, 0, 0 },
		{ 0, 0, 0, 0, 1, 0 },
	};
}

// DFS

void Dfs(int here)
{
	// 방문!
	visited[here] = true;
	cout << "Visited : " << here << endl; // 0 1 2 3 4 5

	// 재귀함수 (끝까지 깊이 들어갔다가 하나씩 돌아나와서 못 찾은 길 실행)
	// 인접 리스트 version
	// 모든 인접 정점을 순회한다
	//for (int i = 0; i < adjacent[here].size(); i++)
	//{
	//	int there = adjacent[here][i];	// 목적지 추출
	//	if (visited[there] == false)
	//		Dfs(there);
	//}

	// 인접 행렬 version
	// 모든 인접 정점을 순회한다
	for (int there = 0; there < 6; there++)
	{
		if (adjacent[here][there] == 0)
			continue;

		// 아직 방문하지 않은 곳이 있으면 방문한다
		if (visited[there] == false)
			Dfs(there);
	}
}

// 5번 정점 같은 끊겨 있는 정점까지 빠짐없이 순회하기 위한 별도의 함수
void DfsAll()
{
	visited = vector<bool>(6, false);

	for (int i = 0; i < 6; i++)
		if (visited[i] == false)
			Dfs(i);
}

int main()
{
	CreateGraph();

	//visited = vector<bool>(6, false);
	//Dfs(0);

	DfsAll();
}
```











## BFS (너비 우선 탐색)
- 입구에서 가까운 얘부터 순차적으로 실행